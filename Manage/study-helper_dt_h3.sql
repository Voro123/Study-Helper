-- MySQL dump 10.13  Distrib 8.0.19, for Win64 (x86_64)
--
-- Host: localhost    Database: study-helper
-- ------------------------------------------------------
-- Server version	8.0.19

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `dt_h3`
--

DROP TABLE IF EXISTS `dt_h3`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `dt_h3` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(80) NOT NULL,
  `introduce` longtext,
  `parentsID` int NOT NULL,
  `sort` int NOT NULL DEFAULT '0',
  `date` date DEFAULT NULL,
  `noappear` tinyint(1) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3302 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dt_h3`
--

LOCK TABLES `dt_h3` WRITE;
/*!40000 ALTER TABLE `dt_h3` DISABLE KEYS */;
INSERT INTO `dt_h3` VALUES (50,'colspan','限定元素:td,tr\n使指定单元格跨/*colspan*/列。',31,0,NULL,0),(51,'border-collapse','限定元素:table\n使表格元素内的单元格边框共享',32,30,NULL,0),(52,'text-decoration','设置文本线条修饰\n可取值(常用):\nnone:默认。无线条修饰\nunderline:下划线\noverline:文本上方的一条线\nline-through:穿过文本的一条线',32,15,NULL,0),(53,'改变颜色深浅','通过增加颜色RGB的整体三色值,以让颜色变浅;\n通过减少颜色RGB的整体三色值,以让颜色变深。\n\n具体可以#fff和#000作参考',33,0,NULL,0),(61,'stylus','1.简介\nstylus的优势是支持原生CSS的语法结合自身语法使用,\"就算全部都用原生CSS写也是没问题的\"。\n\n2.安装依赖\ncnpm install stylus stylus-loader --save\n\n3.使用\n为style元素添加属性lang=\"stylus\"',34,0,NULL,0),(62,'多媒体查询','检测屏宽应用样式的方法如下:\n@media screen and (min-width:/*val*/){/*这里和正常的css一样写*/}\n设置min-width表示当屏宽大于指定值时应用样式;\n设置max-width表示当屏宽小于指定值时应用样式。',33,0,NULL,0),(63,'*calc()计算属性','calc可以在css中任何能使用长度单位的地方使用,其用来计算两个单位的加减乘除,如:\nwidth:calc(100% - 30px)\n则会计算元素的父级宽度减去30px的宽度。\n需要注意的是,计算单位+,-,*,/左右必须有空格。',33,0,NULL,0),(64,'使元素相对于其父级定位','设置该元素position属性为absolute\n并设置其父元素position属性为relative或其他浮动方式',33,0,NULL,0),(65,'锚点or哈希','锚点,又称为哈希,指网页url地址包括#和其后跟的字符串,可以通过location.hash获取。\n通过设置元素的name属性和锚点后字符串相同,可在跳转页面时直接定位到指定name元素所在的位置。',35,0,NULL,0),(66,'-D','全写 --dev\n包名会被注册在package.json的devDependencies里面，仅在开发环境下存在的包用该修饰符，如babel，sass-loader这些解析器',36,0,NULL,0),(67,'--production','适用场景:下载package.json所依赖包时，只下载生产环境的包时可以使用该指令\n(即不会下载通过-D下载的包)',36,0,NULL,0),(68,'跨域','1.跨域是什么？\n跨域，指浏览器不能执行其他网站的脚本，它时由浏览器的同源策略造成的，是浏览器施加的安全限制。\n\n所谓同源，指域名、协议、端口均相同，否则则为跨域。\n\n要注意的是，浏览器只有在执行js脚本时，才会进行跨域检测，所以跳转到其他网站的html页面什么的是完全没有问题的。\n\n2.如何解决？\n在config文件夹的index.js文件中设置如下:\nproxyTable: {  \n  \'/api3000\': {\n    //目标接口域名\n    target: \'http://localhost:3000/\', \n    //是否跨域\n    changeOrigin: true, \n    pathRewrite: {\n     //重写接口\n      \'^/api3000\': \'/api\'\n    }\n  },\n}\n则当浏览器请求本机3000端口数据时，会由/api代理发起申请，接收的服务端需要在\n监听地址前加上/api以获取并返回数据',37,0,NULL,0),(69,'创建vue-cli项目','vue init webpack /*项目名*/',38,0,NULL,0),(70,'统一参数','每个钩子函数都可以接收两个参数:\nel  作用该指令的DOM对象\nbindling  一个对象，可以获取指令的值等信息',39,0,NULL,0),(71,'bind','最先执行，只调用一次，指令第一次绑定到父元素时调用\n在该事件中拿不到元素的父元素',39,0,NULL,0),(73,'inserted','在绑定元素插入到DOM时\n相比bind执行较晚，但此时父元素已生成',39,0,NULL,0),(74,'componentUpdated','指令所在模板发生更新时触发，在相关事件触发后触发',39,0,NULL,0),(75,'update','指令所在模板发生更新时触发，在相关事件触发前触发',39,0,NULL,0),(76,'unbind','在元素被移除时执行\n这个钩子函数很少用到，但偶尔需要和bind合作控制定时器开关等',39,0,NULL,0),(77,'两个更新钩子的差别','update拿到的是数据改变视图之前的视图内容，\n而componentUpdated拿到的是数据改变视图之后的视图内容',39,0,NULL,0),(78,'轮播图 vue-awesome-swiper','1.安装\n安装模块vue-awesome-swiper\n可安装版本2.5.4和2.6.7(推荐前者)\n通过cnpm i vue-awesome-swiper@[版本号] -S下载\n\n2.配置\n前言:如果安装的是2.5.4的版本则无需单独引入样式文件swiper.css\n\n全局引用:\n    import VueAwesomeSwiper from \'vue-awesome-swiper\'\n    import \'swiper/dist/css/swiper.css\'\n    Vue.use(VueAwesomeSwiper, /* { default global options } */)\n【踩坑记录:Vue.use要在new Vue()之前】\n\n局部引用:\n    import \'swiper/dist/css/swiper.css\'\n    import { swiper, swiperSlide } from \'vue-awesome-swiper\'\n    export default {\n    components: {\n      swiper,\n      swiperSlide\n    }\n\n3.使用\n<template>\n  <div class=\"wrapper\">\n    <swiper :options=\"swiperOption\" class=\"swiper-container\">\n      <!-- slides -->\n      <swiper-slide v-for=\"item of swiperList\" :key=\"item.id\">\n        <img class=\"swiper-img\" :src=\"item.imgUrl\" alt=\"\">\n      </swiper-slide>\n      <!-- Optional controls ,显示小点 -->\n      <div class=\"swiper-pagination\" slot=\"pagination\"></div>\n    </swiper>\n  </div>\n</template>\n\n<script>\n/* 引入轮播图模块 */\nimport { swiper, swiperSlide } from \'vue-awesome-swiper\'\nexport default {\n  name: \'HomeSwiper\',\n  components: {\n    swiper,\n    swiperSlide\n  },\n  data () {\n    return {\n      swiperOption: {\n        // 参数选项，显示小点\n        pagination: \'.swiper-pagination\',\n        // 循环\n        loop: true,\n        // 每张播放时长3秒，自动播放\n        autoplay: 2000,\n        // 滑动速度\n        speed: 1000\n        // delay:1000\n      },\n      // 三张轮播，使用变量循环\n      swiperList: [\n        {\n          id: \'001\',\n          imgUrl: \'图片1\'\n        },\n        {\n          id: \'002\',\n          imgUrl: \'图片2\'\n        },\n        {\n          id: \'003\',\n          imgUrl: \'图片3\'\n        }\n      ]\n    }\n  }\n}\n</script>\n\n<!-- >>>穿透作用，因为swiper-pagination-bullet-active类在组件内部定义的，想要wrapper也能\n作用到，可以用>>> -->\n<style lang=\"stylus\" scoped>\n.wrapper >>> .swiper-pagination-bullet-active {\n  background: #ffffff !important;\n}\n\n.wrapper {\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  padding-bottom: 26.66%;\n  background: #eeeeee;\n\n  .swiper-img {\n    width: 100%;\n  }\n}\n</style>\n',40,0,NULL,0),(79,'v-cloak','这个指令将保持在元素上直到关联实例结束编译。\n配合CSS可以在元素被编译完成前将其隐藏\n[v-cloak]{\n   display:none\n}',41,0,NULL,0),(81,'px','',43,0,NULL,0),(82,'vh','当前视图高度的1%',43,0,NULL,0),(83,'vw','当前视图宽度的1%',43,0,NULL,0),(84,'vmax','当前视图宽度和高度较长边的1%',43,0,NULL,0),(85,'vmin','当前视图宽度和高度较短边的1%',43,0,NULL,0),(86,'em','相对于父元素字体大小,如父元素font-size=16px,则1em=16px\n\n【不推荐使用,详情看网址文件夹关于像素】',43,0,NULL,0),(87,'rem','相对于html元素字体大小,如html元素font-size=16px,则1em=16px\n\n【不推荐使用,详情看网址文件夹关于像素】',43,0,NULL,0),(88,'单页面网页 SPA','全称\"single page aplication\"\n指组件化构建网页的形式,在页面中进行操作只通过AJAX替换组件\n\n-优势:\n1.利于前后端分离;\n2.方便维护;\n3.用户体验大幅提升(发出请求不用刷新)\n-劣势:\n1.不兼容低版本浏览器;\n2.其内容不能被SAO搜索引擎搜索到。\n\n适用场景:非电商网站,可广泛用于手机端APP界面开发',35,0,'2020-07-03',0),(89,'JSON.stringify()','将对象转换成JSON形式的字符串。\n将过滤键值为Symbol的属性。',44,136,'2020-07-08',0),(90,'JSON.parse()','将JSON形式的字符串转换为对象',44,134,NULL,0),(91,'nodemon','1.简介\n配置该依赖后可以在每次修改代码时自动重启服务器\n\n2.安装\ncnpm i nodemon -g\n\n3.使用\n将启动node程序方式由node app改为nodemon app',45,0,NULL,0),(92,'深入浅出node.js','讲了很多Node底层的细节\n',46,0,'2020-07-04',1),(93,'Js编程艺术(第二版)','讲了很多js的dom操作,适合js入门',46,0,NULL,0),(94,'Js权威指南','适合在js学一段时间后看,可以了解很多底层的细节(这书1000多页,贼厚)',46,0,NULL,0),(95,'overflow','设置元素内容超出元素本身时的行为\n常用可选值如下:\n1.visible\n默认值。内容会显示在元素之外\n2.hidden\n超出的内容不可见\n3.scroll\n无论内容是否超出元素,出现滚动条以滚动查看元素内容\n4.auto\n内容超出元素时,出现滚动条以滚动查看元素内容',32,30,NULL,0),(96,'background-size','设置元素背景图片的尺寸:\n1.x% y%\n设置图片宽度拉伸至所在元素宽度的x%,高度拉伸至所在元素高度的y%,设置为100% 100%即可设置背景拉到和元素相同尺寸\n2.cover\n将背景图片扩展直到其最短边铺满屏幕,该方法一般会导致图片超出其元素\n3.contain\n将背景图片扩展直到其最长边铺满屏幕,该方法一般会导致图片无法铺满元素',32,22,NULL,0),(97,'npm init','在当前文件添加一个package.json包配置文件\n可加修饰符-y跳过其配置并选择默认配置',47,0,NULL,0),(98,'comment','评论',48,6,NULL,0),(114,'(修饰符)i','匹配时忽略大小写',50,10,'2020-07-05',0),(115,'(修饰符)g','全局匹配',50,10,'2020-07-05',0),(116,'(修饰符)m','如果字符串有换行,按多行匹配',50,10,'2020-07-05',0),(118,'[0-9]','48-57',51,0,NULL,0),(119,'常用ASCII码','1.[0-9]→48-57;\n2.[A-Z]→65-90;\n3.[a-z]→97-122;',52,0,NULL,0),(120,'常用Code码','1.[A-Z]→65-90;\n2.(小键盘)[0-9]→48-57;\n3.(数键)[0-9]→96-105;\n4.(小键盘)Enter→13;\n5.(数键)Enter→108;\n6.空格→8',52,0,NULL,0),(121,'display','指定元素的元素样式:\n1.block\n指定元素为块级元素,默认情况下独占一行。可以使用width,height属性,padding,margin属性均可以使用;\n\n2.inline\n指定元素为内联元素,与其他内联元素共用一行。无法使用width,height属性,高宽由元素内容撑开。padding属性可以正常使用,margin属性只有left,right可以使用\n\n3.inline-block\n指定元素为内联块级元素,与其他内联元素共用一行。可以使用width,height属性,padding,margin属性均可以使用\n\n4.list-item\n元素会作为列表显示\n\n5.flex\n弹性盒样式\n\n6.inline-flex\n行内块弹性盒样式\n',32,28,NULL,0),(122,'spellcheck','指定是否自动检查拼写错误,拼写错误时会在错误处用红色波浪线表示,表单控件自带该属性。',31,0,NULL,0),(123,'resize','指定元素是否可以被用户拖动改变大小,textarea元素默认为true。\n\n可选值:\nnone:默认。用户无法改变元素大小\nboth:用户可以改变元素高度和宽度\nhorizontal:用户可以改变元素宽度\nvertical:用户可以改变元素高度\n\n补充:若希望该值生效,必须设置为元素添加overflow样式属性。',32,28,NULL,0),(124,'userselect','指定用户选中元素内文本时的样式,指定为none使文字不可被选中',32,28,NULL,0),(126,'pointerEvents','指定元素不能响应事件，如click,hover等',32,28,NULL,0),(127,'constructor','指向原型对象的构造函数',53,2,NULL,0),(128,'prototype','指向构造函数的原型对象',53,2,NULL,0),(130,'word-break','指定单词未结束时需要换行的行为。\n可用值如下:\nnormal:默认值。使用浏览器默认的换行规则\nbreak-all 在单词内换行\nkeep-all 只能在半角字符或连字符\"-\"处换行',32,13,NULL,0),(131,'white-space','元素内文本出现空白时的行为\n可用值如下:\n1.normal(默认):浏览器会忽略空白\n2.pre:空格会被保留,等同于标签<pre>\n3.nowrap:文本不会换行\n4.pre-wrap:保留空白,但是正常换行\n5.pre-line:合并空白,但是正常换行',32,28,NULL,0),(132,'text-overflow','设置文本溢出元素时如何处理文本\n可用值如下:\n1.ellipsis:用省略号表示超出的文本\n2.[string]:用给定的字符串表示超出的文本\n3.clip:修剪文本',32,17,NULL,0),(133,'将超出父元素的元素全部隐藏','设置父元素overflow:hidden,并设置超出父元素宽度的元素自动到下一行。\n然后调整父元素高度至只能显示一行子元素的高度,即可实现超出部分隐藏。',33,0,NULL,0),(134,'el.offsetTop','返回元素距离其上级参照物顶端的距离。\n\n上级参照物:即上一个非默认position定位的祖父元素',57,56,NULL,0),(135,'el.clientTop','返回元素上边框宽度',57,50,NULL,0),(136,'el.scrollTop','返回元素滚动位置相对于元素内部顶端的距离。',57,52,NULL,0),(141,'offset()','该方法返回一个对象\n其属性如下:\n1.top 返回元素的绝对位置纵坐标\n2.left 返回元素的绝对位置横坐标',1040,0,NULL,0),(142,'position()','该方法返回一个对象\n其属性如下:\n1.top 返回元素的相对父元素的纵坐标\n2.left 返回元素的相对父元素的横坐标',1040,0,NULL,0),(143,'阿里巴巴图标库','https://www.iconfont.cn/\n英文名:Iconfont\n需要的图标基本都可以在里面找到。\n图标字体使用方法:\n1.进入图标管理-我的项目,新建一个项目\n2.找到你想要的图标,加入购物车\n3.在购物车结算页面点击[添加至项目]\n4.回到之前创建的项目,点击下载至本地\n5.拿到的文件夹丢到项目中,然后通过调用预设类名即可使用对应的字体图标(具体看里面css文件)',1007,0,NULL,0),(144,'菜鸟教程','https://www.runoob.com/\n非常适合新手入门前端的网站。',1007,0,NULL,0),(145,'百度脑图','https://naotu.baidu.com/home\n可以把做项目的一些想法写在上面,类似备忘录。',1007,0,NULL,0),(146,'initial','默认值;初始',48,6,NULL,0),(147,'inherit','继承',48,6,NULL,0),(148,'hook','钩子',48,6,NULL,0),(149,'template','其内容会将整个入口元素替换掉',1008,0,NULL,0),(150,'property','属性,程序中一般简写为prop',48,6,NULL,0),(151,'单向数据流','单向数据流是Vue的通信原则。\n即父组件修改数据,使子组件的props接收数据发生改变。但子组件不能直接修改props接受数据,使父组件数据发生改变。\n其目的是为了避免在多层组件嵌套情况下,内层修改了父组件数据,导致难以定位在哪个内层组件修改的父组件数据,导致程序的应用流向难以理解。',1009,0,'2020-07-18',0),(152,'eval()','作用:将字符串转化为js语句并执行,返回内部js语句返回的结果。\n格式:eval(str)\n参数解释:\nstr:要转化的字符串\n\n例:\nvar a=eval(\'1+2\')=>3',44,145,NULL,0),(153,'黑马-node入门','https://www.bilibili.com/video/BV1Ns411N7HU\n适合Node入门,老师讲的很好懂。',1007,0,NULL,0),(154,'黑马-vue入门','https://www.bilibili.com/video/BV1Rb41177KM?p=73\n适合vue入门.虽然只有一半的课程视频(和讲node入门的是同一个老师)。',1007,0,NULL,0),(155,'.sync','1.概念\n该修饰符用来进行父子组件数据的双向绑定(伪)\n\n2.例子\n<text-document \n  :title.sync=\"doc.title\"\n></text-document>\n等同于\n<text-document\n  v-bind:title=\"doc.title\"\n  v-on:update:title=\"doc.title = $event\"\n></text-document>\n\n其中$event为子组件中通过$emit传递的参数\n\n3.补充\n通过v-bind.sync=\"对象\"（注意没有冒号!!!）,对象中包含所有需要传递双向绑定的数据,即可实现多个值的传递',1010,0,NULL,0),(156,'$emit','格式:this.$emit(\'update:propname\',...参数)\n作用:该方法将触发父组件上的当前组件标签所带的\nv-on:update:propname属性对应的方法,参数将被传递给相应的方法\n\n例:\n—子组件test的某个方法中:\nthis.$emit(\'update:ceshi\',111)\n—父组件的对应子组件test标签:\n<test @update:ceshi=\"ceshi\"></test>\n—父组件的methods对应方法:\nceshi(canshu){\n  console.log(canshu) //=>111\n}\n\n补充:\n前缀\'update:\'并不强制要求,但非常推荐如此使用,因为修饰符.sync在使用时会默认传递的参数前面有这段前缀',1011,0,NULL,0),(158,'enumerable','可枚举性',48,6,NULL,0),(159,'configurable','可配置性',48,6,NULL,0),(160,'descriptor','描述符',48,6,NULL,0),(167,'Reflect.getOwnPropertyDescriptor()','该内部方法用于获取对象特定属性的特性对象。\n无法获取继承属性。\n\n语法:Reflect.getOwnPropertyDescriptor(target,name)\n-target:目标对象\n-name:目标属性字符串\n\n关于属性特性可参阅词条[奇怪的知识增加了]-对象属性的特性',44,115,'2020-07-15',0),(168,'Reflect.defineProperty()','该内部方法用于修改对象属性的特性对象。\n若对象属性不存在,则会被创建。\n\n语法:Reflect.defineProperty(target,propKey, propDesc)\n-target:目标对象\n-propKey:对象属性名\n-propDesc:特性对象\n\n关于属性特性可参阅词条[对象Object]-属性的特性\n',44,120,'2020-07-10',0),(169,'Object.defineProperties()','该方法用于一次添加或修改对象的多个属性特性\n\n语法:Reflect.defineProperties(obj,映射表)\n-obj:目标对象\n-映射表:对象,键名为属性名,值为属性特性\n\n补充:\n1.该方法的返回值为更改后的对象,因此可以在第一个参数传入一个空对象以新建对象\n2.关于属性特性可参阅词条[奇怪的知识增加了]-对象属性的特性\n',44,91,'2020-07-15',0),(173,'typescript是什么？','',1013,0,NULL,0),(174,'深拷贝是什么?怎么做?','',1013,0,NULL,0),(175,'flex的所有设置属性？','',1013,0,NULL,0),(177,'Object.getOwnPropertyNames','该方法用于获取对象所有自有属性,包括不可枚举属性',44,86,NULL,0),(178,'extensible','可扩展的',48,6,NULL,0),(179,'obj.isPrototypeOf()','一、概述\n该方法用于检测指定对象是否为目标对象的原型,返回布尔值。\n\n二、语法\nobj.isPrototypeOf(obj2)\n-obj:指定对象\n-obj2:目标对象\n\n三、补充\n在es5之前,经常使用obj.constructor.prototype来检测一个对象的原型,但这么做是不可靠的。',44,73,NULL,0),(182,'seal','封闭',48,6,NULL,0),(183,'frozen','冻结的',48,6,NULL,0),(184,'freeze','冻结',48,6,NULL,0),(185,'Reflect.preventExtensions()','该内部方法用于修改对象的可扩展性为锁定,即无法添加新的属性\n\n语法:Reflect.preventExtensions(target)\n-target:目标对象',44,114,'2020-07-10',0),(186,'Object.seal()','1.概述\n修改对象的可扩展性为封闭,即无法添加新的属性,且无法对已有属性进行配置或删除\n\n2.语法\nObject.seal(obj)\n-obj:目标对象',44,74,NULL,0),(187,'Object.freeze()','1.概述\n修改对象的可扩展性为冻结,即无法添加新的属性,且无法对已有属性进行配置,删除或修改\n\n2.语法\nObject.freeze(obj)\n-obj:目标对象',44,74,NULL,0),(188,'serialization','序列化',48,6,NULL,0),(189,'notation','符号',48,6,NULL,0),(190,'JSON','全称:JavaScript Object Notation(符号)\n翻译:JavaScript对象表示法',1014,0,NULL,0),(191,'SPA','全称:Single Page Application\n翻译:单页面应用',1014,0,NULL,0),(192,'infinity','无穷大',48,6,NULL,0),(193,'obj.hasOwnProperty()','一、概述\n该方法返回一个布尔值,判断目标字符串是否为自身的属性。\n\n二、语法\nobj.hasOwnProperty(propname)',44,72,NULL,0),(195,'arr.push()','一、概述\n在数组末尾添加一个或多个元素,返回添加后的数组长度。\n\n二、语法\narr.push(...el)\n-arr:目标数组\n-el:添加的元素',44,61,'2020-07-06',0),(196,'arr.unshift()','一、概述\n在数组头部插入一个或多个元素,返回添加后的数组长度。\n\n二、语法\narr.unshift(...el)\n-arr:目标数组\n-el:插入的元素',44,63,'2020-07-06',0),(197,'arr.pop()','一、概述\n删除数组尾部的一个元素,返回被删除的元素。\n\n二、语法\narr.pop()',44,58,'2020-07-06',0),(198,'arr.shift()','一、概述\n删除数组头部的一个元素,返回被删除的元素。\n\n二、语法\narr.shift()',44,60,'2020-07-06',0),(199,'性能优化的方法','1.循环优化\n在for循环中的条件判断表达式的语句每次循环都会被完整执行,有些情况会亏损性能。\n错误示例:\nfor(let i=0;i<arr.length;i++){}\n// 以上数组中,每次遍历都会查询数组的长度,可以使用一个变量将这个长度保存起来以多次使用。\n正确示例:\nfor(let i=0,len=arr.length;i<len;i++){}\n\n2.回收内存优化\njs具有垃圾回收机制,当浏览器检测到某个变量将不再被使用时,自动释放该变量所占的内存。\n而对于对象,浏览器将检测是否还有变量指向对象所占堆内存地址,当检测到没有变量再指向该对象的堆内存地址时,将其释放。\n所以如果要回收对象的内存,可以将所有指向这个对象的变量赋值为null。\n示例:\nlet obj={a:1}\nobj=null\n\n3.函数调用优化\n见本页【函数尾调用】\n',1016,14,'2020-07-06',0),(201,'obj[iterator].forEach()','一、概述\n该方法用于按索引顺序遍历对象的每一个元素并将其作为参数传递给要执行的方法\n\n二、语法\nobj.forEach(func(val,key,obj2),thisVal)\n-val:当前遍历元素键值\n-key:可选。当前遍历元素键名\n-obj2:可选。当前遍历元素所属对象\n-thisVal:可选。函数执行时this的指向\n\n三、缺陷\n不能使用break语句中断循环，也不能使用return语句返回到外层函数。\n',44,68,'2020-07-09',0),(202,'matrix','矩阵',48,6,NULL,0),(203,'arr.sort()','一、概述\n对数组进行排序,将影响原数组。默认情况下按照字母表排序,也可以传入一个函数以指定如何排序。\n\n二、语法\narr.sort(func(a,b))\n-func(a,b):a为比较的第一个数,b为比较的第二个数,js内部进行排序时,它将依次使用数组中的两个元素作为参数调用该方法。若返回值<0,表示第一个参数应该在前;若>0,表示第二个参数应该在前;若=0,表示不发生改变。',44,50,NULL,0),(204,'arr.concat()','一、概述\n该方法将连接两个或多个数组,并将结果传递给调用数组。\n\n二、语法\narr.concat(...arr2)\n-arr:原数组,结果将改变该数组\n-arr2:被连接的数组',44,50,NULL,0),(205,'arr.slice()','一、概述\n该方法将截取数组的一部分并返回一个新数组,不会改变原数组。\n\n二、语法\narr.slice(a,b)\n-a:开始截取的位置\n-b:可选。结束截取的位置-1。\n\n三、补充\n将参数指定为负数时将从数组末尾开始计算,如-1指数组最后一位',44,50,'2020-07-08',0),(206,'arr.splice()','一、概述\n该方法是插入或删除元素的通用方法,将返回被替换的部分,改变原数组。\n\n二、语法\narr.splice(a,b,...c)\n-a:开始替换的位置下标\n-b:可选。替换的长度\n-c:可选。用来替换的新元素\n\n三、补充\nsplice()方法非常灵活,可以用来插入和删除元素,也可以同时完成这两件事。\n1.删除元素\narr.splice(5) //=>将删除数组下标为5的元素及其之后的元素\narr.splice(5,2) //=>将删除数组下标为5的元素开始的2位元素\n2.插入元素\narr.splice(5,0,\'aaa\',\'bbb\') //=>将在数组第5位之前插入两个元素\'aaa\'和\'bbb\',并使其之后的数组元素下标+1\n3.替换元素\narr.splice(5,2,\'aaa\',\'bbb\') //=>将把数组第5位开始2个元素替换为\'aaa\',\'bbb\'\n\n四、优化\n若只是希望删除数组中的一个元素,将数组末尾与要删除的元素互换,并使arr.length-=1在性能上能优化许多。\n',44,50,NULL,0),(207,'arr.map()','一、概述\n将调用的数组的每个元素传递给指定函数,并返回新的数组,该方法不改变原数组。\n\n二、语法\narr.map(func(val,index,arr2),thisVal)\n-val:当前遍历的元素\n-index:可选。当前遍历的元素下标\n-arr2:可选。当前遍历的元素所在数组\n-thisVal:可选。函数的this指向\n\n三、补充\nforEach与map方法的区别仅在forEach修改原数组,而map返回一个新数组\n\n四、缺陷\n不能使用break语句中断循环，也不能使用return语句返回到外层函数。\n',44,50,NULL,0),(208,'arr.filter()','一、概述\n将调用的数组的每个元素传递给指定函数,当函数返回true时,在新数组中加入该元素,该方法不改变原数组。\n\n二、语法\narr.filter(func(val,index,arr2),thisVal)\n-val:当前遍历的元素\n-index:可选。当前遍历的元素下标\n-arr2:可选。当前遍历的元素所在数组\n-thisVal:可选。函数的this指向\n\n三、实例\nvar arr=[1,2,8,9]\nnewarr=arr.filter(function(val){\n   return val>5\n})\nconsole.log(newarr) //=>[8,9]\n\n四、补充\n若数组中有元素未定义(稀释数组),则filter方法将跳过它们并总是返回一个稠密数组',44,50,NULL,0),(209,'arr.every()','一、概述\n将调用的数组的每个元素传递给指定函数,若遍历的每个元素返回true,则该方法返回true,否则返回false\n\n二、语法\narr.every(func(val,index,arr2),thisVal)\n-val:当前遍历的元素\n-index:可选。当前遍历的元素下标\n-arr2:可选。当前遍历的元素所在数组\n-thisVal:可选。函数的this指向',44,50,NULL,0),(210,'arr.some()','一、概述\n将调用的数组的每个元素传递给指定函数,若有任何一个遍历的元素返回true,则该方法返回true,否则返回false\n\n二、语法\narr.some(func(val,index,arr2),thisVal)\n-val:当前遍历的元素\n-index:可选。当前遍历的元素下标\n-arr2:可选。当前遍历的元素所在数组\n-thisVal:可选。函数的this指向',44,50,NULL,0),(211,'arr.reduce()','一、概述\n该方法用于遍历数组的元素执行函数,并保留执行的结果进行下一次遍历,将返回最后一次函数执行的结果。\n\n二、语法\narr.reduce(func(a,b),initialVal,thisVal)\na:上一次遍历的结果,若为第一次遍历,则为initialVal的值;若未指定initialVal,则跳过第一次遍历并返回第一个元素\nb:当前遍历的元素\ninitialVal:可选。初始值\nthisVal:可选。this指向\n\n三、示例\narr=[1,2,3]\nvar n=arr.reduce(function(a,b){\n  return a+b\n},4)\nconsole.log(n) //=>10',44,48,NULL,0),(212,'arr.reduceRight()','一、概述\n该方法用于从右到左遍历数组的元素执行函数,并保留执行的结果进行下一次遍历。\n\n二、语法\narr.reduceRight(func(a,b),initialVal,thisVal)\na:上一次遍历的结果,若为第一次遍历,则为initialVal的值;若未指定initialVal,则跳过第一次遍历并返回第一个元素\nb:当前遍历的元素\ninitialVal:可选。初始值\nthisVal:可选。this指向\n\n三、示例\narr=[1,2,3]\nvar n=arr.reduce(function(a,b){\n  return a+b*2\n})\nconsole.log(n) //=>1+2*2+3*2=11\nvar m=arr.reduceRight(function(a,b){\n  return a+b*2\n})\nconsole.log(m) //=>3+2*2+1*2=9\n\n四、补充\nreduce和reduceRight的唯一区别在于reduceRight从右到左遍历数组。',44,48,NULL,0),(213,'arr.indexOf()','一、概述\n返回数组中第一个值为指定值的元素下标\n\n二、语法\narr.indexOf(el,beginIndex)\n-el:查找的元素值\n-beginIndex:开始查找的位置\n\n三、补充\n该方法内部使用了===运算符,因此无法判断NaN元素,若希望弥补这个缺陷,可以用ES6新增的arr.find()和arr.findIndex()方法\n',44,48,'2020-07-06',0),(214,'arr.lastIndexOf()','一、概述\n返回数组中最后一个值为指定值的元素下标\n\n二、语法\narr.lastIndexOf(el,beginIndex)\n-el:查找的元素值\n-beginIndex:开始查找的位置,将从指定位置倒序开始查找',44,46,NULL,0),(215,'duration','持续时间',48,6,NULL,0),(216,'animation-name','指定播放动画的名称。',32,28,NULL,0),(217,'animation-duration','指定动画完成的时间',32,28,NULL,0),(218,'animation-delay','指定动画延时几秒播放',32,28,NULL,0),(219,'animation-iteration-count','指定动画重复次数。\n可选值如下:\n[n]s:n秒\ninfinite:表示无限重复播放。',32,28,NULL,0),(220,'animation-direction','指定动画是否在偶数周期逆向播放。\n\n可选值如下:\nnormal:默认值,否\nalternate:是',32,28,NULL,0),(221,'animation-play-state','指定动画正在运行或是暂停。\n\n可选值如下:\npaused:正在暂停\nrunning:正在播放',32,26,NULL,0),(222,'animation-fill-mode','指定动画未播放时,元素的样式。\n\n可选值如下:\nnone:默认。不改变默认行为\nforwards:当动画完成时,保持最后一帧的属性值\nbackwards:在animation-delay时间内,应用动画第一帧初始属性值\nboth:同时应用forwards和backwards',32,27,NULL,0),(223,'background-attchment','指定元素的背景图像是否随其滚动条位置滚动\n\n可选值如下:\nscroll:默认值。背景图像随滚动条位置滚动\nfixed:当页面其余部分滚动时,背景图像不会滚动',32,20,NULL,0),(224,'background-postion','设置元素背景图像的起始位置\n\n可选值如下:\nx% y%:表示元素的背景图像在元素的横轴x%,纵轴y%处\n\n补充:\n为元素设置background-attchment:fixed以保证该属性在所有浏览器下可用',32,20,NULL,0),(225,'background-repeat','设置元素的背景图像如何重复。\n\n可选值如下:\nrepeat:默认值。背景图像将在水平和垂直方向上重复\nrepeat-x:背景图像将在水平方向上重复\nrepeat-y:背景图像将在垂直方向上重复\nno-repeat:背景图像不重复',32,20,NULL,0),(226,'background-clip','设置背景图像的绘制区域。\n\n可选值如下:\nborder-box:背景裁剪到边框盒\npadding-box:背景裁剪到内边距框\ncontent-box:背景裁剪到内容框',32,20,NULL,0),(227,'background-origin','设置背景图像相对于哪里来定位。\n\n可选值如下:\npadding-box:相对于内边距框来定位\nborder-box:相对于边框盒来定位\ncontent-box:相对于内容框来定位\n\n补充:\n若background-attchment设置为fixed,则该属性没有效果',32,20,NULL,0),(229,'outline','轮廓',48,6,NULL,0),(230,'source','来源',48,6,NULL,0),(231,'border-image-source','设置边框填充图片\n\n可选值如下:\nurl(图片地址)',32,20,NULL,0),(232,'border-image-slice','设置边框图片的向内偏移量。\n\n可选值如下:\na%( b% c% d%):可指定最多4个偏移值,其设置规则和padding一致。\n[a]px:(...)\nfill:保留边框图像的中间部分',32,20,NULL,0),(233,'border-image-width','设置边框图片的宽度。\n\n可选值如下:\na%( b% c% d%):可指定最多4个宽度值,其设置规则和padding一致。\n[a]px:(...)\nauto:宽度为对应图像切片的固有宽度',32,20,NULL,0),(234,'border-image-outset','规定边框图像超过边框的量。\n\n可选值如下:\n[a]px:可指定最多4个偏移值,其设置规则和padding一致。\nnumber:对应相应background-image-width的倍数',32,20,NULL,0),(235,'border-image-repeat','设置边框图片如何显示。\n\n可选值如下:\nrepeat:重复图片来填充区域\nstretch:拉伸图片来填充区域\nround:同repeat,但若无法完整平铺所有图像,对图像进行缩放以适应区域',32,20,NULL,0),(236,'*box-shadow','为元素边框添加阴影\n\n其值格式为:\nbox-shadow:h-shadow v-shadow blur spread color inset\nh-shadow:必需。水平阴影的位置,允许负值。\nv-shadow:必需。垂直阴影的位置,允许负值。\nblur:模糊距离。\nspread:阴影尺寸。\ncolor:阴影颜色。\ninset:将外部阴影改为内部阴影。',32,20,NULL,0),(237,'opacity','设置元素的透明度(从0.0到1.0)',32,20,NULL,0),(238,'font-style','设置字体的风格。\n\n可选值如下:\nnormal:默认。浏览器显示一个标准的字体样式\nitalic:斜体风格\noblique:倾斜风格',32,20,NULL,0),(239,'font-weight','设置字体粗细\n\n可用值如下:\nnormal:默认。\nbold:粗体\nbolder:加粗体\nlighter:字体将比正常更细',32,20,NULL,0),(240,'counter-reset','创建或重置一个计时器。\n\n值格式如下:\ncounter-reset:id number\nid:计时器的id,以便进行读取\nnumber:可选。初始化或重置的值,默认为0\n\n补充:\n读取一个计时器的值的格式为counter(id)',32,18,NULL,0),(241,'counter-increment','指示该选取器每次出现时定时器的递增/减量\n\n值格式如下:\ncounter-increment:id number\nid:指定定时器的id\nnumber:每次的递增量,可以为负数',32,18,NULL,0),(242,'list-style-type','设置ul列表的项目标记样式为预设样式\n\n可用值如下:(仅记录常用的)\nnone:取消项目标记\ndisc:默认。实心圆\ncircle:空心圆\nsquare:实心方块\nupper-roman:大写罗马数字(I,II,III,IV,V等)\nlower-alpha:小写字母\nupper-alpha:大写字母\n...',32,18,NULL,0),(243,'list-style-image','设置ul列表的项目标记样式为指定图片\n\n值格式如下:\nlist-style-image:url(图片路径)',32,18,NULL,0),(244,'list-style-position','设置ul项目标记的位置。\n\n可用值如下:\ninside:列表项目标记放置在文本内,且环绕文本根据标记对齐\noutside:默认值。列表项目标记放置在文本之外',32,18,NULL,0),(245,'column-count','规定元素应该被分隔的列数。\n\n可选值:\n[number]:可以用数字直接指明分隔列数\nauto:由其他属性决定列数,如column-width',32,18,NULL,0),(246,'column-fill','规定如何对列进行填充。\n\n可选值:\nbalance:对列进行协调,浏览器应对列长度的差异进行最小化处理\nauto:按顺序对列进行填充,列长度会各有不同',32,18,NULL,0),(247,'column-gap','规定列与列之间分隔线左右的总间隔\n\n可选值:\n[length]:将列间间隔设置为指定的长度\nnormal:规定列间间隔为一个常规的间隔',32,18,NULL,0),(248,'column-rule-color','设置列之间分隔线的颜色\n\n值格式:[color]',32,18,NULL,0),(249,'column-rule-style','设置列与列之间的分隔线线条样式。\n\n可选值:\nnone:取消分隔线\nhidden:隐藏分隔线\ndotted:点状\ndashed:虚线\nsolid:实线\ndouble:双实线',32,18,NULL,0),(250,'column-rule-width','设置列间分隔线的宽度\n\n值格式:[length]',32,18,NULL,0),(251,'column-span','指定元素应该跨多少列\n\n值格式:[count]||all\nall:元素将跨越所有列',32,18,NULL,0),(252,'column-width','指定每一列的宽度。\n\n值格式:[length]||auto\nauto:由浏览器决定宽度',32,18,NULL,0),(253,'clip','裁剪绝对定位元素的四个方向\n\n值格式:[top] [right] [bottom] [left]',32,18,NULL,0),(254,'cursor','设置用户光标在元素上时的样式\n\n可选值:(仅记录常用值)\nurl(图片路径):用自选图片代替光标,若选择该值,应再在其前定义一个普通光标,以防目标图片丢失\ndefault:默认光标。一般是一个箭头\nauto:默认值。浏览器设置的光标\ncrosshair:十字状\npointer:手状,常用值\nmove:指示元素可被拖动\ntext:在文字上时的鼠标样式\nhelp:帮助样式\n...',32,18,NULL,0),(255,'float','规定元素是否浮动。\n\n可用值:\nleft:向左浮动\nright:向右浮动\nnone:默认值。不浮动\n\n补充:\n浮动元素一般情况下都不会压住文字。',32,18,NULL,0),(256,'*vertical-align','设置元素的基线相对于父元素的基线的垂直对齐\n\n可用值:\nbaseline:默认值。元素放置在父元素的基线上\nsub:垂直对齐文本的下标\nsuper:垂直对齐文本的上标\ntop:对齐父元素的顶端\nmiddle:对齐父元素的中间\nbottom:对齐父元素的底部\ntext-bottom:对齐父元素文本的底部\n[%]:使用line-height的百分比来排列元素,允许使用负值\n\n补充:\n如果希望元素居中,可以在父元素内设置一个与要垂直居中元素同级的inline-block元素,高度为父元素的100%,vertical-align属性为middle',32,18,NULL,0),(257,'position','规定元素如何定位。\n\n可用值如下:\nstatic:(默认值)按正常文档流定位\nrelative:相对定位\nabsolute:绝对定位,相对于static以外的第一个父元素定位\nfixed:绝对定位,相对于浏览器窗口定位\nsticky:粘性定位,若元素按正常文档流在用户浏览器视窗内,则按正常文档流排序;否则根据top,left属性决定元素相对于浏览器窗口定位。该值尚未被所有浏览器支持',32,18,NULL,0),(258,'border-spacing','限定元素:table\n设置表格内单元格的横、纵间距\n\n值格式:[x]px [y]px\nx为横间距,y为纵间距\n若省略y,则横纵间距都将设置为x',32,18,NULL,0),(259,'empty-cells','限定元素:table\n设置表格中的空单元格如何显示。\n\n可用值:\nshow:默认值。在空单元格周围绘制边框\nhide:不在空单元格周围绘制边框',32,18,NULL,0),(260,'table-layout','限定元素:table\n指定表格内单元格超出其宽度时的行为。\n\n可用值如下:\nautomatic:默认值。列宽度由单元格内容决定\nfixed:列宽度由单元格宽度决定',32,18,NULL,0),(261,'*letter-spacing','设置元素内字符间距。\n\n值格式:\nletter-spacing:[a]px\na:字符间距,可以是负数',32,18,NULL,0),(262,'line-height','设置当前元素内字体的行高\n\n可用值:\n[a]px:直接指定字体高度\na%:指定当前元素字体大小的a%',32,18,NULL,0),(263,'text-indent','指定元素文本首行的缩进,允许使用负值。\n\n值格式:[a]px',32,18,NULL,0),(264,'text-shadow','指定元素内文本的阴影效果。\n\n值格式:h-shadow v-shadow blur color\nh-shadow:水平阴影的位置,允许负值\nv-shadow:垂直阴影的位置,允许负值\nblur:可选。模糊的距离\ncolor:可选。阴影的颜色',32,18,NULL,0),(265,'text-transform','设置元素内文本的字母大小写。\n\n可用值:\nnone:默认。\ncapitalize:文本中的每个单词以大写字母开头。\nuppercase:所有字母转化为大写。\nlowercase:所有字母转化为小写。',32,18,NULL,0),(266,'Unicode','一、概述\nUnicode(统一码)是计算机科学领域的一种业界标准,它是为了解决传统字符编码方案而产生的。它为每种语言的每个字符设定了统一且唯一的字符编码,以满足跨语言、跨平台的转换。\n\n二、起源\n因为计算机只能处理数字,而无法处理文本,所以要把文本转换为数字处理。\n\n最早的计算机设计将8个比特(bit)存储为1个字节(byte),这样1个字节能代表的字符就只能有255个。而ASCII编码将0-127位作为大小写英语字母、数字和一些其他符号,解决了用计算机表示字母和数字的问题。\n\n但这样显然是不够的,中文和一些其他国家的语言无法再计算机上用八进制表示出来,于是,Unicode编码应运而生。\n\nUnicode编码通常用两个字节(十六进制)来表示一个字符,原有的英语字母也全都改为用两个字节表示。\n\nutf-8,utf-16,utf-32则是将数字转换为程序数据的编码方案。\n\n三、补充\n中文Unicode编码区间:4E00-9FBF',1014,0,NULL,0),(267,'word-spacing','设置元素中文本的单词间距。\n\n值格式:[a]px\na:单词间距,允许设为负值以让单词之间的距离的更紧',32,14,NULL,0),(269,'word-wrap','允许长单词换行到下一行。\n\n可用值:\nnormal:默认。只在允许的断字点换行\nbreak-word:在长单词或url地址内部进行换行',32,14,NULL,0),(270,'*transform','对元素进行2D/3D转换,包括旋转、缩放、移动和倾斜操作\n\n可用值:\nnone:默认值。不进行任何转换\n\ntranslate([x]px,[y]px):移动。向右平移x,向下平移y,允许负值\n\nscale([x],[y]):缩放。宽度变为原宽度x倍,高度变为原高度y倍\n\nrotate([a]deg):2D旋转。a为旋转的角度,旋转的基点位置由 transform-origin 属性决定\n\nrotate3d([x],[y],[z],[angle]deg):3D旋转。x(从下向上旋转),y(从左到右旋转),z(以方框中心为原点,顺时针旋转)分别为三个角度旋转的矢量值(0.0-1.0),angle是旋转的角度\n\nskew([x]deg,[y]deg):倾斜。x为向x轴正方向的倾斜角度,y为向y轴正方向的倾斜角度\n\n补充:\n1.若需要同时使用一种以上的变换效果,需要用空格隔开\n2.若要制作3d盒子的效果,可以先做出2d平面图再改成3d',32,10,NULL,0),(271,'有的css加前缀的原因(不同浏览器)','例:-webkit-transform: rotateX(120deg)\n\n在标准还未确定时，部分浏览器已经根据最初草案du实现了部分功能。\n为了与之后确定下来dao的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分。\n当标准确立后，各大浏览器将逐步支持不带前缀的css新属性',33,0,NULL,0),(272,'transform-origin','设置元素旋转时的基点位置。\n\n值格式:\ntransform-origin:[x-axis] [y-axis] [z-axis]\n\n其参数解释如下:\nx-axis:指定基点被置于x轴的何处,可能的值有left,center,right,[length],[x%]\ny-axis:指定基点被置于y轴的何处,可能的值有top,center,bottom,[length],[y%]\nz-axis:指定基点被置于z轴的何处,可能的值有[length]',32,10,NULL,0),(273,'CSS性能优化','1.安卓上使用left属性会导致卡顿。\n可以使用transform:translateX代替',33,0,NULL,0),(274,'perspective','指示元素与视图的距离。父元素设置该属性后,允许设置其子元素的transformZ属性。该属性尚未被所有浏览器支持。\n\n值格式:[a]px',32,10,NULL,0),(275,'angle','角度',48,6,NULL,0),(276,'transform-style','设置元素的子元素怎么在三维空间呈现。\n\n可用值:\nflat:默认。所有子元素在2d平面中呈现\npreserve:所有子元素在3d空间中呈现',32,10,NULL,0),(277,'设置3D动画效果','1.可以先将3D元素以2D形式呈现,然后再进行翻转等操作变成3D\n\n2.设置父元素perspective属性为1000px(一般),否则\n3d移动转换属性将无法被应用\n\n3.设置父元素transform-style属性为preserve-3d,否则父元素旋转时看不到子元素的3d转换效果',33,0,NULL,0),(278,'degree','角度。\n可缩写为deg',48,6,NULL,0),(279,'*transition','设置元素的过渡效果,是四个过渡CSS属性的缩写版。\n\n值格式:\ntransition :[transition-property] [transition-duration] [transition-timing-function] [transition-delay]\ntransition-property:指定要应用过渡的属性,可取值all表示所有属性都需要过渡\ntransition-duration:指定过渡的持续时间\ntransition-timing-function:指定过渡动画的速度曲线,其值格式为cubic-bezier(n,n,n,n),n是0.0-1.0间的一个浮点数,使用贝塞尔曲线进行速度曲线计算\ntransition-delay:指定过渡的延时',32,10,NULL,0),(280,'outline','为元素添加轮廓(位于边框之外)\n\n值格式:\noutline:[w]px [style] [color]\nw:轮廓宽度\nstyle:线条样式\ncolor:轮廓颜色',32,10,NULL,0),(281,'outline-offset','设置元素轮廓的向外偏移值。\n\n值格式:[a]px',32,10,NULL,0),(282,'horizontal','水平',48,6,NULL,0),(283,'vertical','垂直',48,6,NULL,0),(284,'*','选择所有元素。',1017,2,NULL,0),(285,'+el','选择当前元素之后的符合条件的兄弟元素。\n\n例:div+p\n表示div之后同级的所有p元素',1017,2,NULL,0),(286,'[attr]','选择带有指定属性的所有元素。',1017,0,NULL,0),(287,'[attr]~=val','选择所有指定属性字符串中带有指定值的元素。',1017,0,NULL,0),(288,'[attr]|=val','选择所有指定属性以指定值开头的元素。\n\n也可以写成[attr^=val}',1017,0,NULL,0),(289,':link','选择所有未被访问的链接。',1017,0,NULL,0),(290,':visited','选择所有已访问过的链接。',1017,0,NULL,0),(291,':active','选择处于活动状态的链接,活动状态类似于鼠标按在该链接上时的状态。',1017,0,NULL,0),(292,':focus','选择获得焦点的input元素。',1017,0,NULL,0),(293,':first-letter','选择元素的文本首字母',1017,0,NULL,0),(294,':first-line','选择元素的首行文本',1017,0,NULL,0),(295,'~el','选择下一个兄弟元素为指定元素的元素。\n\n例:\np~div 则会选择页面中所有前一个兄弟元素是p的div元素',1017,1,NULL,0),(296,'[attr$=val]','选择所有指定属性以val结尾的指定元素。',1017,0,NULL,0),(297,'::-webkit-slider-thumb','限定元素:input[type=range]\n设置滚动条元素的滑动块样式。\n\n注意:必须配合-webkit-appearance: none使用,去除系统的默认样式。',1017,0,NULL,0),(298,':only-of-type','选择属于其父元素唯一指定元素的元素。',1017,0,NULL,0),(299,':nth-of-type(a+bn)','选择其父元素下第a+bn个指定子元素。',1017,0,NULL,0),(300,':nth-last-of-type(a+bn)','选择其父元素下倒数第a+bn个元素。',1017,0,NULL,0),(301,'*:empty','指定没有子元素的指定元素',1017,0,NULL,0),(302,':target','选择当前指向的锚点链接',1017,0,NULL,0),(303,'::selection','选择被用户选中的文本',1017,0,NULL,0),(304,'\'Comic Sans MS\', cursive, sans-serif','比较可爱的字体。',1018,0,NULL,0),(305,'Tahoma, Geneva, sans-serif','让人感觉粗体比较能突出重点。',1018,0,NULL,0),(306,'\'Trebuchet MS\', Helvetica, sans-serif','有趣的字体',1018,0,NULL,0),(307,'Georgia, serif','很适合正经场合的字体',1018,0,NULL,0),(308,'\'Palatino Linotype\', \'Book Antiqua\', Palatino, serif','比较清秀的字体',1018,0,NULL,0),(309,'W3C','W3C(World wide web Consortium)指万维网联盟,它们的主要工作是发展Web规范,这些规范描述了Web的通信协议(如HTML和XHTML)和其他构建模块。',1014,0,NULL,0),(310,'HTML5','HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。\n\nHTML5的设计目的是为了在移动设备上支持多媒体。\n\nHTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。',35,0,NULL,0),(312,'header','指示元素包含页面头部内容',1019,0,NULL,0),(313,'nav','指示元素包含页面导航内容',1019,0,NULL,0),(314,'navbar','导航栏',48,6,NULL,0),(315,'article','指示元素包含可独立主体内容',1019,0,NULL,0),(316,'aside','指示元素包含页面侧边栏内容',1019,0,NULL,0),(317,'footer','指示元素包含页面底部内容',1019,0,NULL,0),(318,'valid','有效',48,6,NULL,0),(395,'切图-Cutterman','一个PS切图插件,能完成一键图层选中区域导出的操作。\n价格:免费\n要求:ps不是绿色版,可通过查看ps窗口-扩展功能看里面是不是灰的,灰的就是绿色版,不能用',1022,0,NULL,0),(396,'*CSS属性书写顺序','形成良好的CSS书写习惯能使代码看起来更简洁,在修改时也更一目了然。\n\n(1)位置属性(position, top, right, z-index, display, float等)\n\n(2)大小(width, height, padding, margin)\n\n(3)文字系列(font, line-height, letter-spacing, color, text-align等)\n\n(4)背景(background, border等)　　(5)其他(animation, transition等)',33,1,NULL,0),(397,'精灵图技术','一、概述\n  精灵图技术是将一个页面的所有需要的图片整合到一张大图中,并在需要时从这种大图里获取需要图片部分的技术。\n\n二、为什么需要精灵图技术?\n  在浏览器加载页面时,需要的每一张图片,浏览器都会向服务器发送一次请求。若页面有50张图片,浏览器就要向服务器发送50次请求,这样对服务器的压力过大,因此需要使用精灵图技术对图片进行整合。\n\n三、精灵图的使用\n  通过CSS属性background-position配合PS标尺调整使用对应图片。\n\n四、精灵图的缺点\n1.图片体积比较大\n2.图片本身放大和缩小容易导致失真\n3.图片制作完毕后,想更换非常复杂',52,0,NULL,0),(398,'margin负值的巧妙应用','\n若有两个盒子元素相邻,都通过float:left浮动。\n若希望他们相邻的边框重叠的话,不能直接都设置border-width:1px。这样会导致两边的边框同时存在,中间的边框变成2px。\n\n此时可以巧妙运用margin的负值,设置盒子的margin-left:-1px,后面盒子的边框就巧妙地盖掉了前面的边框。\n\n此时会有一个疑问:两个盒子同时向左1像素,那它们之间的边框不还是2px吗?\n答案是不会,因为两个盒子都是通过float:left排版的。\n浏览器在渲染时,会先渲染前面的元素,第一个元素渲染时确定了向左1像素。然后再渲染第二个,因为float属性,这个元素会直接去贴向左一格的第一个元素,然后再执行自身的margin-left,所以不用担心这个问题。',33,0,NULL,0),(399,'CSS初始化','一、概念\n指为了照顾不同浏览器和版本元素默认样式的差异,每个网页都需要进行CSS初始化\n\n二、方法\n直接去网上扒一份初始化CSS拿去用',33,0,NULL,0),(400,'section','指示元素包含文档的某块区域。',1019,0,NULL,0),(401,'关于语义化元素','1.语义化元素主要是为了针对搜索引擎SEO的\n\n2*.在IE8及以下版本的IE浏览器,需要将语义化元素转化为块级元素(浏览器默认未知元素为内联元素),并声明语句\n<!--[if lt IE 9]>\n<script src=\"http://api.html5media.info/3.7.3/html5media.min.js\"></script>\n<![endif]-->\n以上语句的作用是检测到浏览器内核版本低于ie9时,引入html5media库,该库包含实现html5语义化的所有功能',1019,1,NULL,0),(402,'关于移动端h5兼容','移动端是完全不用担心html5兼容的。',1023,0,NULL,0),(403,'<video>','一、概述\nhtml5允许在不使用插件的情况下,播放视频格式文件的播放。当然,支持的视频格式是有限的。\n\n二、基本语法\n<video src=\"文件地址\"></video>\n\n三、标签元素常见属性(-后为属性的可选值)\n1.autoplay:指示视频是否自动播放。注意:对于谷歌浏览器,需要同时指定muted属性才可自动播放。\n  -autoplay\n2.muted:指示视频是否静音播放。\n  -muted\n3.controls:指示是否显示自带的暂停,静音等控件。注意:实际开发中一般不指定该属性,转而用js编写视频控件\n  -controls\n4.loop:指示视频是否循环播放。\n  -loop\n5.preload:指示视频是否预加载(在页面刚刚加载完视频未播放时自动加载它的内容)。\n  -auto:预加载  -none:从不\n6.poster:指示视频未播放时显示的图片。\n  -imgurl:图片路径\n\n四、补充\n<video>支持的格式有mp4,WebM和Ogg,其中,WebM和Ogg格式的视频文件都不被IE,Safari浏览器支持,因此尽量使用mp4格式的视频文件。\n但还有个问题,Firefox和Opera的低版本不支持mp4格式,这时就需要为这种情况提供候补其他格式的视频:\n<video controls=\"controls\">\n   <source src=\"movie.mp4\" type=\"video/mp4\">\n   <source src=\"movie.ogg\" type=\"video/ogg\">\n   你的浏览器不支持video元素。\n</video>\n靠前的视频会被优先尝试加载,若加载成功就不会再加载其后的视频文件了。\n若所有视频格式加载失败,则会显示末尾的内容,即此处的一段文字\"你的浏览器不支持video元素\"',1024,0,NULL,0),(404,'<audio>','一、概述\nhtml5允许在不使用插件的情况下,播放音频格式文件的播放。当然,支持的音频格式是有限的。\n\n二、基本语法\n<audio src=\"文件地址\"></audio>\n\n三、标签元素常见属性(-后为属性的可选值)\n1.autoplay:指示音频是否自动播放。该属性也被谷歌浏览器禁用了,且不同于视频,这个只能通过js解决。\n  -autoplay\n2.controls:指示是否显示自带的暂停,静音等控件。\n  -controls\n3.loop:指示是否循环播放。\n  -loop\n4.preload:是否进行预加载。\n  -auto:预加载 -none:从不\n\n四、补充\n和video元素一样,audio允许向下兼容:\n<video controls=\"controls\">\n   <source src=\"movie.mp4\" type=\"video/mp4\">\n   <source src=\"movie.ogg\" type=\"video/ogg\">\n   你的浏览器不支持audio元素。\n</video>',1024,0,NULL,0),(405,'main','指示元素时文档的主要内容,一个网页只有一个main元素。',1019,0,NULL,0),(406,'figure','指示元素是独立的流内容,删除后不应对文档流产生影响。',1019,0,NULL,0),(407,'contenteditable','指定用户能编辑该元素的文本内容',1026,0,NULL,0),(408,'data-*','h5允许给元素自定义新的属性,以便在js中对带有指定自定义属性的元素进行特殊的处理。\n\n例:<div data-focus=\"true\"></div>\n\n补充:\n元素的自定义属性集合对象可以通过el.dataset获取',1026,0,NULL,0),(409,'draggable','指示元素时候可拖拽。\n\n值格式为布尔值,为true时则应用属性特性。',1026,0,NULL,0),(410,'hidden','指示元素不可见。\n\n只要指定了该属性,元素就不可见,无法通过修改html标签来修改元素的显示与否,必须通过js来修改其值为false或删掉该属性使元素可见。',1026,0,NULL,0),(411,'mark','指示元素内文本为标记文本,该标签内的文本会被用黄色标记',1019,0,NULL,0),(412,'progress','指示元素是一个进度条。\n\n属性:\nmax(num):进度条的最大值\nvalue(num):当前进度',1019,0,NULL,0),(413,'address','指示元素内包含个人或某个组织的联系信息等。',1019,0,NULL,0),(416,'autocomplete','规定form和input应该拥有自动完成功能。(自动获取用户之前填写的信息并提供快捷输入)\n\n限定元素:表单元素\n值格式:on/off',1026,0,NULL,0),(417,'novalidate','该属性设置为true时,规定用户提交表单时浏览器不对其进行验证并直接提交。\n\n限定元素:表单元素\n值格式:true/false\n\n例:\n通常情况下,浏览器会在表单提交时对提交信息进行验证。\n<form>\n  <input type=\"email\">\n</form>\n如此处浏览器会验证用户输入的input格式是否为email，若检测到不是,则会取消验证并由浏览器弹出一个报错信息。\n将novalidate设置为true即可禁用。',1026,0,NULL,0),(418,'autofocus','规定元素在进入页面时自动获得焦点。\n\n限定元素:表单元素',1026,0,NULL,0),(419,'formaction','该属性用于描述表单提交的url地址,将覆盖form表单元素的action属性。\n\n限定元素:表单元素>submit\n\n补充:使用该属性可实现同一表单与不同后端接口交互。',1026,0,NULL,0),(420,'formmethod','该属性用于描述表单提交的方式,将覆盖form表单元素的method属性。\n\n限定元素:表单元素>submit,image\n\n补充:使用该属性可实现同一表单与后端接口不同交互方式。',1026,0,NULL,0),(421,'formnovalidate','该属性设置为true时,规定用户提交表单时浏览器不对其进行验证并直接提交,将覆盖form表单的novalidate属性。\n\n限定元素:表单元素>submit',1026,0,NULL,0),(422,'formtarget','该属性指定元素提交数据后的展示。\n\n限定元素:表单元素>submit\n\n可选值:\n_blank:在一个新的窗口打开\n_self:在当前页面打开',1026,0,NULL,0),(423,'list','指向输入域应用的datalistID。\n\n限定元素:表单元素\n\n补充:\n详细用法可以看【html5标签元素】=>【datalist】。',1026,0,NULL,0),(424,'multiple','规定元素可以选择多个值。\n\n限定元素:表单元素',1026,0,NULL,0),(425,'multiple','多选;复选',48,6,NULL,0),(426,'pattern','图案;模式',48,6,'2020-07-05',0),(427,'pattern','规定一个正则表达式来验证表单值。\n\n限定元素:表单元素>text,search,url,tel,email,password\n\n值格式:regex',1026,0,NULL,0),(428,'Regex','全写为Regular Expression,也可缩写为Regexp,指正则表达式。\n\n即通过单个字符串来描述、匹配一系列语法规则。',1014,0,NULL,0),(429,'required','规定输入框不能为空。',1026,0,NULL,0),(430,'<datalist>','该元素规定输入域的选项列表,即用户在输入框获取焦点时出现一个下拉箭头,包含一些预设的值可供用户直接选择。\n\n使用方法:\n<input type=\"text\" list=\"class\" />\n<datalist id=\"class\">\n   <option value=\"hello world\"></option>\n   <option value=\"good morning\"></option>\n</datalist>\n注意:datalist的id必须和绑定输入框元素的list属性对应',1024,0,NULL,0),(431,'<output>','用于实时通过特定表达式计算表单内的值并显示。\n\n使用方法:\n<form oninput=\"x.value=a.value+b.value\">\n  <input type=\"number\" id=\"a\" value=\"50\">\n  <input type=\"number\" id=\"b\" value=\"30\">\n  <outinput name=\"x\" for=\"a b\">\n</form>\n此时页面初始化时,会自动获取表单a(50)和表单b(30)的值,并将它们相加,得到的结果显示在outinput中(80)。\n此后每当两个表单中任意一个值发生变化,outinput的值都会重新计算。',1024,0,NULL,0),(432,'type=\"color\"','选取一种颜色。',1028,0,NULL,0),(433,'type=\"date\"','选择一个日期。',1028,0,NULL,0),(434,'前言','大多数html5表单类型未被所有浏览器良好支持,不要过度依赖这些表单类型',1028,1,NULL,0),(435,'type=\"email\"','检测用户输入的内容是否为邮箱格式。\n兼容性较好,几乎所有浏览器支持这个属性。',1028,0,NULL,0),(436,'type=\"number\"','input元素内仅允许输入数字。',1028,0,NULL,0),(437,'type=\"range\"','定义一个滑动条。\n\n属性如下:\nmin:滑动条的最小值\nmax:滑动条的最大值\nvalue:滑动条的当前值\n\n补充:可以通过::-webkit-slider-thumb伪类改变滑动块的样式。',1028,0,NULL,0),(439,'::placeholder','设置元素占位符的样式',1017,0,NULL,0),(440,'type=\"time\"','选择一个时间(无时区)。',1028,0,NULL,0),(441,'type=\"url\"','检测用户输入的内容是否为url格式。\n兼容性较好,几乎所有浏览器支持这个属性。',1028,0,NULL,0),(442,'query','查询;询问',48,6,'2020-07-14',0),(443,'document.querySelect()','获取单个元素。\n\n语法:document.querySelect(selector)\nselector:任意CSS选择器字符串',1029,0,NULL,0),(444,'document.querySelectAll()','获取多个元素集合。\n\n语法:document.querySelectAll(selector)\nselector:任意CSS选择器字符串',1029,0,NULL,0),(445,'document.classList','获取元素的类集合对象,该对象内置一些方法,能对该元素的类进行操作。\n\n内置方法:\n1.add(classname)\n为元素添加类\n2.remove(classname)\n移除元素的指定类\n3.contains(classname)\n检测元素是否包含指定类,返回布尔值\n4.toggle(classname)\n若元素不存在指定类,添加,反之移除',1029,0,NULL,0),(446,'el.dataset','获取元素的自定义属性集合对象。\n其键值对应自定义属性名,值对应自定义属性值。\n该值可写。',1029,0,NULL,0),(447,'type=\"file\"','允许用户选择一个或多个文件以提交表单的方式上传到服务器上。\n\n属性:\nvalue:已选择文件的路径,若选择了多个文件,该值只带有选中的第一个文件路径。可以在js中通过input元素的files属性获取。\naccept:描述允许选择文件的类型,以唯一文件类型说明符格式声明其值,多个类型用逗号隔开。\nfiles:指出FileList对象每个已选择的文件及其相关属性集合。\nmultiple:声明该属性时,允许用户选择多个文件。',1030,0,NULL,0),(448,'获取数据类型','通过typeof可以简单获取基本的数据类型Number,String等。\n但若是判断Array,Map一类引用数据类型,typeof通通会返回Object,显然不是想要的结果。\n\n此时可以通过{}.toString.call(data)解决\n对象独有的toString方法能准确的返回数据的类型,可以利用这种特性,通过call更改执行体为想要判断的数据来解决。',1016,10,NULL,0),(449,'FileReader','一、概述\n构造函数,用于配合file表单元素读取客户端文件。\n\n二、原型方法\n1.readAsBinaryString:将文件读取为二进制编码\n2.readAsDataURL:将文件读取成DataURL\n3.readAsTest:将文件读取成文本\n\n三、钩子函数\n1.onloadstart:开始读取文件时触发\n2.onprogress:读取文件时触发,读取完成前该函数将反复执行\n3.onabort:读取文件中断时触发\n4.onerror:读取文件出错时触发\n5.onload:读取文件成功时触发\n6.onloadend:读取文件结束时触发,无论成功失败都会触发\n\n四、使用方法:(file_input为页面的对应file表单元素)\nfile_input.onchange=function(){\n  // 获取用户选择的文件集合第一个元素\n  var files=this.files[0];\n  \n  // 创建读取器\n  var reader = new FileReader();\n\n  // 开始读取\n  reader.readAsText(file);\n\n  // 读取完成后,返回读到的结果\n  reader.onload = function(){\n    console.log(reader.result)\n  }\n}',1029,0,NULL,0),(450,'binary','二进制',48,6,NULL,0),(451,'window.navigator.onLine','检测浏览器的网络状态,联网状态返回true,断网状态返回false',1029,0,NULL,0),(452,'navigator.geolocation','允许用户向web应用程序提供它们的地理位置,处于安全考虑,报告地理位置前会先请求用户许可。\n\n这个属性因不明原因在国内不能很好地起到作用,经常查询不到用户的地理位置信息,建议使用百度地图开放平台API作取代。\nhttp://lbsyun.baidu.com/index.php?title=jspopular3.0',1029,0,NULL,0),(454,'window.localStorage','一、概述\n该对象提供了本地存储数据的一些API。\n传统方式中,网页开发者往往通过document.cookie进行存储,但由于其存储大小只有4k左右,且解析较为困难。h5便提供了新的存储数据对象localStorage和sessionStorage\n\n二、特点\n1.永久存储\n2.多窗口共享\n3.容量约20M\n\n三、内置方法\n1.setItem(key,value)\n设置存储内容\n2.getItem(key)\n获取存储内容\n3.removeItem(key)\n删除存储内容\n4.clear()\n清空存储内容\n\n四、补充\n建议只存储字符串类型的数据,尽管h5规范中允许存储任意类型的数据,但目前还没有浏览器对其实现。\n\n',1029,0,NULL,0),(455,'storage','存储',48,6,NULL,0),(456,'window.sessionStorage','一、概述\n该对象提供了本地存储数据的一些API。\n传统方式中,网页开发者往往通过document.cookie进行存储,但由于其存储大小只有4k左右,且解析较为困难。h5便提供了新的存储数据对象localStorage和sessionStorage\n\n二、特点\n1.生命周期仅维持到当前浏览器窗口的关闭\n2.仅可以在同一个窗口下访问\n3.数据大小为5M左右\n\n三、内置方法\n1.setItem(key,value)\n设置存储内容\n2.getItem(key)\n获取存储内容\n3.removeItem(key)\n删除存储内容\n\n四、补充\n建议只存储字符串类型的数据,尽管h5规范中允许存储任意类型的数据,但目前还没有浏览器对其实现。\n',1029,0,NULL,0),(457,'JS书写规范(个人)','1.习惯性在代码结束处留下一行空白,这样下次书写d代码时就能直接从最后一行开始写下去。\n\n2.一段功能实现后,应在其后留下一行空白再书写之后的代码,这样会显得代码条理更加清晰。\n\n3.加不加分号无所谓,但是要加就全都加,不加就全都别加,这样代码能更加美观。\n\n4.计算符左右习惯性留下一个空白字符,能提升代码的易读性。\n\n5.构造函数应以大写字母开头。\n\n6.在一个对象不再使用后应该将指向该对象地址的所有变量置空(null)。\n\n7.多行定义的对象,以一个逗号结尾;单行定义的低下,不以逗号结尾。\nlet obj = {\n  a: 1,\n  b: 2,\n}\nlet obj2 = {a:1,b:2}\n\n8.对象尽量静态化,避免添加属性,如果添加属性不可避免,使用Object.assign()来添加属性。\n\n',1016,15,'2020-07-18',0),(458,'前言','多媒体指<audio>和<video>元素。',1032,0,NULL,0),(460,'background-image','设置元素的背景图片。\n\n可选值:\n1.[url]:选择图片地址以应用背景图片\n2.linear-gradient:线性渐变\n3.gadial-gradient:径向渐变\n\n补充:\n复合背景图片样式可用逗号隔开,其他有关背景图片的属性设置也用逗号隔开，如background-size,先写的背景图片会显示在上层。',32,24,NULL,0),(461,'canPlayType()','该方法检测浏览器是否能播放指定格式的音视频。\n\n语法:video|audio.canPlayType(type)\n参数:\ntype:规定要检测的音频/视频类型,常用值有\n  ①video/ogg   ②video/mp4  ③video/webm\n  ④audio/mpeg  ⑤audio/ogg  ⑥audio/mp4\n\n返回值(String):\n\"probably\" - 最有可能支持\n\"maybe\" - 可能支持\n\"\" - （空字符串）不支持\n',1032,0,NULL,0),(462,'*load()','该方法用于重新加载音视频元素,常用于更改来源或其他设置后对音视频进行更新。\n\n语法:audio|video.load()\n',1032,0,NULL,0),(463,'*play()','开始播放音视频\n\n语法:audio|video.play()\n',1032,0,NULL,0),(464,'*pause()','暂停当前播放的音视频\n\n语法:audio|video.pause()\n',1032,0,NULL,0),(465,'autoplay','设置或返回音视频是否自动播放\n\n可用值:true/false\n',1032,0,NULL,0),(466,'buffered','一、概述\n该属性返回一个TimeRanges对象。TimeRanges对象表示用户的音视频缓冲范围。\n缓冲范围指用户已缓冲的音视频时间范围,若用户跳跃播放,则会有多个缓冲范围。\n\n二、原生方法\n1.length:返回音视频中缓冲范围数量\n2.start(index):返回第index段缓冲范围的起始时间(以秒计)\n3.end(index):返回第index段缓冲范围的结束时间(以秒计)\n',1032,0,NULL,0),(467,'controls','设置或返回音视频时候显示默认音视频控件。\n\n可用值:true/false\n\n补充:一般在实际开发中,都不会用默认的controls属性',1032,0,NULL,0),(468,'currentSrc','返回当前播放音视频的url地址',1032,0,NULL,0),(469,'*currentTime','设置或返回当前音视频的播放进度(以秒计)。',1032,0,NULL,0),(470,'*duration','返回音视频的时间总长度(以秒计)。',1032,0,NULL,0),(471,'ended','判断当前音视频是否已播放结束,返回布尔值。',1032,0,NULL,0),(472,'loop','设置或返回视频是否循环播放。\n\n可用值:true/false',1032,0,NULL,0),(473,'muted','设置或返回音视频是否静音\n\n可用值:true/false',1032,0,NULL,0),(474,'*networkState','返回音视频的加载情况。\n\n返回值(Number):\n- 0 音频/视频尚未初始化\n- 1 音频/视频是活动的且已选取资源，但并未使用网络\n- 2 浏览器正在下载数据\n- 3 未找到音频/视频来源',1032,0,NULL,0),(475,'paused','返回当前音视频是否被暂停。\n\n可用值:true/false',1032,0,NULL,0),(476,'preload','设置或返回页面是否在加载后就立即缓冲音视频。\n\n可用值:\nauto:页面加载完成,立即开始缓冲\nmetadata:页面加载完成,仅加载音视频的元数据\nnone:从不',1032,0,NULL,0),(477,'*readyState','返回当前音视频的播放就绪状态。\n\n返回值(Number):\n- 0 没有关于音频/视频是否就绪的信息\n- 1 关于音频/视频就绪的元数据\n- 2 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒\n- 3 当前及至少下一帧的数据是可用的\n- 4 可用数据足以开始播放',1032,0,NULL,0),(478,'seekable','返回首个以秒计的视频可寻址范围。\n可寻址范围指的是用户在音频/视频中可寻址（移动播放位置）的时间范围。\n对于流视频，通常可以寻址到视频中的任何位置，即使其尚未完成缓冲。\n\n返回值(TimeRanges):\nlength:获得音频/视频中可寻址范围的数量\nstart(index):获得可寻址范围的开始位置\nend(index):获得可寻址范围的结束位置',1032,0,NULL,0),(479,'seeking','返回用户是否在音视频中寻址(跳跃到某个时间范围)。\n\n返回值:true/false',1032,0,NULL,0),(480,'src','设置或返回当前音视频的来源。',1032,0,NULL,0),(481,'*volume','设置或返回音视频的音量。\n\n可用值(Number):0.0~1.0',1032,0,NULL,0),(483,'el.clientHeight','获取元素的内部高度,包含内边距,但不包含水平滚动条,边框和外边距。',57,44,NULL,0),(484,'func.bind()','改变函数的this指向,不执行函数。\n\n语法:func.bind(el)\nel:新的this指向',44,34,NULL,0),(485,'func.call()','改变函数的this指向并立即执行函数。\n\n语法:func.call(el)\nel:新的this指向',44,34,NULL,0),(486,'func.apply()','改变函数的this指向并立即执行函数,与call()的区别在于apply可以将参数作为一个数组传入。\n\n语法:func.call(el,paras)\nel:新的this指向\nparas:参数数组',44,34,NULL,0),(487,'路飞学城-html5入门','https://book.apeland.cn/details/489/#%E6%96%B0%E7%9A%84input%E7%B1%BB%E5%9E%8B\n\n学习html5入门还算不错。',1007,0,NULL,0),(488,'abort','设置音视频终止加载时触发的事件。\n该事件是在多媒体数据终止下载时触发，而不是发生错误时触发。\n',1034,0,NULL,0),(489,'loadstart','音视频加载过程开始时触发事件。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(490,'durationchange','视频时长发生变化时,触发事件。\n当音视频加载后，时长将由 \"NaN\" 变为音视频的实际时长。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(491,'loadedmetadata','音视频元数据加载完成时,触发事件。\n\n音视频的元数据包括：时长、尺寸（仅视频）以及文本轨道。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(492,'loadeddata','当前帧的数据已加载,但没有足够的数据来播放指定音视频的下一帧时,触发事件。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(493,'progress','当浏览器正在下载指定的音视频时,触发事件。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(494,'canplay','当浏览器能够开始播放指定的音视频时,触发事件。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(495,'canplaythrough','当浏览器预计能够在不停下来进行缓冲的情况下持续播放指定的音视频时,触发事件。\n\n补充:\n当音频/视频处于加载过程中时，会依次发生以下事件:\n1.loadstart\n2.durationchange\n3.loadedmetadata\n4.loadeddata\n5.progress\n6.canplay\n7.canplaythrough\n',1034,0,NULL,0),(496,'emptied','当目前的播放列表为空时触发事件。\n',1034,0,NULL,0),(497,'ended','当目前的播放列表已结束时触发事件。\n',1034,0,NULL,0),(498,'error','当在音视频加载期间发生错误时触发事件。',1034,0,NULL,0),(499,'pause','当音视频已暂停时触发事件。\n',1034,0,NULL,0),(500,'play','当音视频已开始或不再暂停时触发事件。',1034,0,NULL,0),(501,'playing','当音视频在因缓冲而暂停或停止后已就绪时触发事件。\n',1034,0,NULL,0),(502,'*playbackRate','设置或返回音频/视频的当前播放速度\n\n可用值(Number):\n1.0 默认值。正常速度\n0.5 半速\n2.0 两倍速\n-1.0 视频以正常速度反向播放\n-0.5 视频以半速反向播放',1032,0,NULL,0),(503,'ratechange','音视频播放速度发生改动时触发事件。\n',1034,0,NULL,0),(504,'seeking','用户开始移动/跳跃到音视频中的新位置时触发事件。\n',1034,0,NULL,0),(505,'seeked ','用户已移动/跳跃到音视频中的新位置时触发事件。\n',1034,0,NULL,0),(506,'*stalled','浏览器尝试获取媒体数据，但数据不可用时触发事件。\n',1034,0,NULL,0),(507,'*suspend','浏览器刻意不加载(被阻止)媒体数据时触发事件。\n',1034,0,NULL,0),(508,'timeupdate','音视频播放位置被改变时触发。\n该事件会在开始播放音视频被调用一次。\n',1034,0,NULL,0),(509,'volumechange','当音量被更改后触发事件。\n',1034,0,NULL,0),(510,'waiting','音视频由于需要缓冲下一帧而停止时触发。',1034,0,NULL,0),(511,'适合当背景的颜色','#efebcb 舒缓的淡黄色',1035,0,NULL,0),(512,'body-parser','若希望接受post传递的数据,用原生node写法会很麻烦,这时就可以引入这个包进行快捷操作。\n\n配置方法:(app为express实例,在导入路由前配置)\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\n\n使用方法:req.body',1036,0,NULL,0),(513,'express','提供了很多能简化原生node繁琐语句的接口。',1036,0,NULL,0),(514,'mysql','提供连接和操作mysql数据库的接口。\n\n// 实例(DbHelper.js)\n// 该模块用于进行调用数据库操作\nconst mysql = require(\'mysql\')\nvar obj = {}\n\n// 连接数据库\nfunction connect (callback) {\n  // 创建连接数据库信息实例\n  var connection = mysql.createConnection({\n    host: \'localhost\',\n    user: \'root\',\n    password: \'123456\',\n    database: \'study-helper\'\n  })\n  connection.connect((err, result) => {\n    if (err) return console.log(err)\n    callback(connection);\n  })\n}\n\n//查询数据库并返回数据\nobj.DbSelect = function (cmdstr, callback) {\n  // 如果传了个空语句,直接返回true\n  if (cmdstr === \'\') {\n    return callback(true)\n  }\n\n  connect(function (connection) {\n    connection.query(cmdstr, function (err, rows) {\n      // 断开连接\n      connection.end();\n      if (err) {\n        console.log(err);\n        return console.log(err)\n      }\n      callback(rows)\n    })\n  })\n}\n\n//添加列并返回结果(布尔值)\nobj.DbExecute = function (cmdstr, callback) {\n  // 如果执行的是delete语句且没有where限制,直接返回(防止误删)\n  if (cmdstr.match(/^delete.*/) && !cmdstr.match(/.*where.*/)) return callback(false)\n\n  // 如果传了个空语句,直接返回true\n  if (cmdstr === \'\') {\n    return callback(true)\n  }\n\n  connect(function (connection) {\n    connection.query(cmdstr, function (err) {\n      // 断开连接\n      connection.end();\n      if (err) {\n        console.log(err);\n        return callback(false)\n      }\n      callback(true)\n    })\n  })\n}\n\nmodule.exports = obj;',1036,0,NULL,0),(515,'animation-timing-function','指定动画将如何完成一个周期。\n\n可选值:\n1.cubic-bezier(p1x,p1y,p2x,p2y)\n4个参数组成了一条三阶贝塞尔曲线。\n参数为0到1的整数\n\n2.steps(number_of_steps, direction)\n阶梯函数,该函数将动画的总时长按等距划分,并以定格动画的形式展示。\nnumber_of_steps:正整数,将动画总时长按阶梯数等距划分\ndirection:可选值。start或end，默认end，也可以不写；start表示动画的第一帧会被立即执行,直接从第二帧开始，然后以第一帧结束；end则表示动画从第一帧开始到正常结束；',32,25,NULL,0),(516,'transparent','透明',48,6,NULL,0),(517,'MVC开发模式','一、M-Model 封装数据操作\n二、V-View 视图渲染\n三、Controller 控制器(打杂)',1014,0,NULL,0),(518,'deny','否认;拒绝\n\n过去时:denied 被拒绝',48,6,NULL,0),(519,'*Chinese','装完后VsCode界面将汉化。',1037,4,NULL,0),(520,'Prettier','格式化js,html,css代码,建议在Setting中配置为保存内容触发格式化。',1037,0,NULL,0),(521,'*Bracket Pair Colorizer2','为每对大括号添加不同的颜色,以便快速区分它们的位置。',1037,0,NULL,0),(522,'Auto Rename Tag','html标签重命名时,对应的结束标签也会同步重命名。',1037,0,NULL,0),(523,'Live Server','在本地开启一个Http Server,并且监听用户保存文件动作进行页面自动刷新。',1037,0,NULL,0),(524,'Live Sass Compiler','监听并实时编译scss文件,输出css文件。',1037,0,NULL,0),(525,'折叠/展开代码(js,html,css)','ctrl+k,然后再点击ctrl+0折叠当前文件所有代码(js,html,css)\n\nctrl+k,然后再点击ctrl+j展开当前文件所有代码(js,html,css)',1038,0,NULL,0),(526,'volume','音量',48,6,NULL,0),(527,'grey','灰色',48,6,NULL,0),(528,'-webkit-appearance','去除浏览器自带元素样式。',32,10,NULL,0),(529,'::-webkit-slider-thumb','限定元素:input[type=range]\n设置滚动条元素的滑动块样式',1017,0,NULL,0),(530,'whole','所有的',48,6,NULL,0),(531,'transform','转换',48,6,NULL,0),(532,'ctx.fillRect()','绘制一个填充颜色的矩形。\n\n语法:fillRect(x,y,width,height)\nx,y(Number):绘制矩形的左上角坐标\nwidth,height(Number):矩形的大小',1039,0,NULL,0),(533,'ctx.strokeRect()','绘制一个只填充边框的矩形\n\n语法:strokeRect(x, y, width, height)\nx,y(Number):矩形的左上角坐标\nwidth,height(Number):矩形的大小',1039,0,NULL,0),(534,'ctx.clearRect()','清除矩形区域,使被清除部分完全透明。\n\n语法:clearRect(x, y, width, height)\nx,y(Number):矩形的左上角坐标\nwidth,height(Number):矩形的大小',1039,0,NULL,0),(535,'*canvas.getContext()','该方法返回一个 CanvasRenderingContext2D 对象，该对象实现了一个画布所使用的大多数方法。\n\n语法:canvas.getContext(contextID)\ncontextID:指定希望绘制的图像类型\n   可选值2d,表示2d绘图\n',1039,0,NULL,0),(536,'ctx.fillStyle','指定画笔的填充颜色。\n\n例:ctx.fillStyle=\'#000\'\nctx:通过canvas.getContext()返回的对象',1039,0,NULL,0),(537,'ctx.strokeStyle','指定画笔的描边颜色。\n\n例:ctx.strokeStyle=\'#fff\'\nctx:通过canvas.getContext()返回的对象',1039,0,NULL,0),(538,'ctx.beginPath()','新建一条路径，生成之后，图形绘制api被指向到路径上生成路径。无参数。',1039,0,NULL,0),(539,'*ctx.moveTo()','将画笔移动到指定坐标上。\n当canvas初始化或者beginPath()调用后,通常会使用moveTo()函数设置起点。\n\n语法:ctx.moveTo(x,y)\nx,y:画笔移动到的坐标',1039,0,NULL,0),(540,'ctx.lineTo()','绘制一条从画笔当前位置到指定位置的直线。\n\n语法:ctx.lineTo(x,y)\nx,y:目标位置',1039,0,NULL,0),(541,'ctx.closePath()','闭合路径。',1039,0,NULL,0),(542,'ctx.stroke()','通过路径闭合图形来绘制图形轮廓。',1039,0,NULL,0),(543,'ctx.fill()','填充路径闭合图形。',1039,0,NULL,0),(544,'ctx.arc()','绘制圆弧或圆。\n\n语法:arc(x,y,radius,startAngle,endAngle,anticlockwise)\nx,y:圆心坐标\nradius(Number):半径长度\nstartAngle(Number):绘制起始角度\nendAngle(Number):绘制终点角度\nanticlockwise(Boolean):为true时,逆时针绘制图形,默认值为false',1039,0,NULL,0),(545,'ctx.quadraticCurveTo()','绘制二次贝塞尔曲线。\n\n语法:quadraticCurveTo(cp1x,cp1y,x,y)\ncp1x,cp1y:控制点1的坐标\nx,y:结束点坐标',1039,0,NULL,0),(546,'ctx.bezierCurveTo()','绘制三次贝塞尔曲线。\n\n语法:bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\ncp1x,cp1y:控制点1坐标\ncp2x,cp2y:控制点2坐标\nx,y:结束点坐标',1039,0,NULL,0),(547,'ctx.globalAlpha','设置画笔透明度值。\n\n可取值:0.0 ~ 1.0',1039,0,NULL,0),(548,'ctx.lineWidth','设置线条长度,数值无单位。',1039,0,NULL,0),(549,'ctx.lineCap','设置线段末端的样式。\n\n可用值:\nbutt:默认。平直的边缘\nround:圆形线帽\nsquare:方形线帽\n\n补充:round和square都会为线条增加其长度/2的图形来显示线帽。',1039,0,NULL,0),(550,'ctx.lineJoin','指定线条的拐角处如何绘制。\n\n可用值:\nmiter:默认。创建尖角\nbevel:创建斜角\nround:创建圆角',1039,0,NULL,0),(551,'ctx.fillText()','渲染填充文本。\n\n语法:ctx.fillText(text,x,y,[,maxWidth])\ntext:要渲染的文本内容\nx,y:渲染文本的左上角坐标\nmaxWidth:绘制的最大宽度',1039,0,NULL,0),(552,'ctx.strokeText()','渲染文本边框。\n\n语法:ctx.strokeText(text,x,y,[,maxWidth])\ntext:要渲染的文本内容\nx,y:渲染文本的左上角坐标\nmaxWidth:绘制的最大宽度',1039,0,NULL,0),(553,'ctx.font','设置绘制文本的样式。\n采用和CSS font属性相同的语法。\n\n值格式:ctx.font = fontsize font-family\nfontsize:字体大小。默认为10px\nfont-family:字体。默认为sans-serif',1039,0,NULL,0),(554,'ctx.textAlign','设置文本的对齐。\n\n可用值:\nstart:默认。文本在指定的位置开始\nend:文本在指定的位置结束\ncenter:文本的中心被放在指定的位置\nleft:文本左对齐\nright:文本右对齐',1039,0,NULL,0),(555,'ctx.textBaseline','设置文本的基线对齐。\n\n可用值:\nalphabetic:默认。文本基线为普通字母基线\ntop:文本基线在文本顶部\nhanging:文本基线是悬挂基线\nmiddle:文本基线在文本正中\nideographic:文本基线是表意基线\nbottom:文本基线在文本底部',1039,0,NULL,0),(556,'ctx.direction','设置文本方向。\n\n可用值:\nltr:从左到右\nrtl:从右到左\ninherit:默认。继承父项',1039,0,NULL,0),(557,'ctx.drawImage()','将一张图片绘制到画布上。\n可以使用另一个canvas画布作为图像源。\n\n语法:ctx.drawImage(imgObj,x,y,width,height,dx,dy,dWith,dHeight)\nimgObj:图像源,须为image或者canvas对象\nx,y:图像源的切片左上角坐标\nwidth,height:图像源的切片大小\ndx,dy:绘制图像的左上角坐标\ndWidth,dHeight:绘制图像的缩放后大小\n\n补充:若为3个参数,则第二、三个参数表示绘制图像的左上角坐标\n\n\n例:\nvar img = new Image();\nimg.onload = function() {\n    ctx.drawImage(img, 0, 0);\n    ctx.beginPath();\n    ctx.moveTo(123, 400);\n    ctx.lineTo(198, 350);\n    ctx.lineTo(300, 200);\n    ctx.lineTo(500, 150);\n    ctx.stroke();\n}\nimg.src = \'image-20190703114102416.png\';',1039,0,NULL,0),(558,'ctx.save()','保存画笔的当前状态(如位置,颜色,线条长度等)。\n一般与restore()配合使用。\n\n补充:若多次保存画笔的状态,读取时会获得最后一次保存的画笔状态,之后再次读取会获得倒数第二次保存的画笔状态。(也就是说对某次画笔状态进行读取会导致该状态被销毁,下次无法再读取该状态)\n',1039,0,NULL,0),(559,'ctx.restore()','恢复画布到上一次保存的状态。\n一般与save()配合使用。\n\n补充:若多次保存画笔的状态,读取时会获得最后一次保存的画笔状态,之后再次读取会获得倒数第二次保存的画笔状态。(也就是说对某次画笔状态进行读取会导致该状态被销毁,下次无法再读取该状态)\n',1039,0,NULL,0),(560,'ctx.translate()','将画笔以当前所在位置进行偏移。与moveTo()不同的地方在于:moveTo是直接使画笔跳转至指定坐标,而translate()是使画笔在当前位置进行偏移。\n\n语法:ctx.translate(x,y)\nx:横坐标偏移\ny:纵坐标偏移\n',1039,0,NULL,0),(561,'ctx.rotate()','使画笔绘制的方向按顺时间旋转指定角度。\n\n语法:ctx.rotate(deg)\ndeg:旋转的角度,以弧度计\n\n补充:若须将角度转换为弧度,可以通过deg*Math.PI/180计算',1039,0,NULL,0),(562,'requestAnimationFrame()','该方法告诉浏览器你希望执行一个动画,并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。\n\n回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。\n\n语法:requestAnimationFrame(callback)\n\n此外,回调函数有一个默认的形参timestamp,它指示从浏览器打开到本次回调执行经过了多少毫秒。\n',56,6,'2020-07-18',0),(563,'如何通过canvas制作动画','一、更新动画函数的处理\n1.清空canvas\n通过clearReact()来清空canvas，保证自己的画布是干净的\n2.保存canvas状态\n3.绘制动画图形\n4.恢复canvas状态\n\n二、操控动画的方法\nA.setInterval(functuon,delay)\n在设定好间隔时间后，function会定期执行\n\nB.setTimeout(function,delay)\n在设定好的时间之后执行函数\n\nC.requestAnimationFrame(callback)\n此方法一般每秒钟回到函数执行60次。告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。',1023,0,NULL,0),(564,'SVG','SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。\n',1014,0,NULL,0),(565,'比较canvas和svg','一、描述:\n1.canvas\n- 通过js绘制的2D图形。\n- 逐像素渲染。\n\n2.svg\n- 基于XML描述的2D图形的语言,这意味着，SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。\n- 是通过对图形的数学描述来绘制的图形(矢量图形),因此无论如何放大缩小都不会失真。\n- 每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\n- 本身是文本文件,因此体积较小。\n\n二、有了svg为什么还要用canvas\n从以上可以看出,svg各方面都超越了canvas,那为什么还要使用canvas呢?\nsvg在绘图面积小,但数据大时性能较差,渲染时间较长,而canvas则恰恰相反。\n\n三、应用场景\n在绘图面积大,数据小时使用svg绘制较好。\n在绘图面积小,数据大时使用canvas绘制较好。\n\n\n',1023,0,NULL,0),(566,'XML','全写为EXtensible Markup Language。\n可扩展标记语言，被设计用于结构化、传输和存储数据，核心在于数据的内容。\n其具有严格的格式要求,如所有元素必须有关闭标签；标签对大小写敏感；必须正确嵌套；必须有根元素；属性值必须加引号等。\n不同于html,XML没有类似HTML的预定义标签（如head、body、h1、p），XML的标签由文档的创作者决定，它被设计为具有自我描述性',1014,0,NULL,0),(567,'XHTML','全写为EXtensible HyperText Markup Language。\n具备XML严格语法的HTML。\nXML1.0是以XML重构的HTML4.01。\nXHTML的设计目的原本是为了取代HTML,但随着html5的推出,它便被废弃了。\n但其整洁的格式受到一部分开发者的喜欢,html5将它的书写风格保留了下来并融汇进严格模式中,开发者可以自行选择代码的宽松或严格检查。',1014,0,NULL,0),(568,'<svg>','svg代码都放在顶层标签<svg>中。\n\n属性:\nwidth,height：指定svg图像在html元素中所占据的高宽,允许以百分比的形式表示。如果不指定,默认的宽高是300px*150px\n',1041,0,NULL,0),(569,'<circle>','绘制一个圆形。\n\n属性:\ncx,cy(Number)：指定圆心坐标\nr(Number)：半径\n',1041,0,NULL,0),(570,'<canvas>','定义一个画布元素。\n\n接口属性和方法具体参考【canvas画布属性/方法】。',1024,0,NULL,0),(571,'<svg>','定义一个矢量图元素。\n\n内部标签元素具体参考【svg矢量图标签】。\n\nsvg内部元素独有的css属性:\nfill:填充色\nstroke:描边色\nstroke-width:边框宽度',1024,0,NULL,0),(574,'str.match()','使字符串匹配指定正则表达式并返回匹配结果。\n\n语法:str.match(reg)\nreg:要匹配的正则表达式',44,23,NULL,0),(575,'fill','限定元素:svg内部标签元素\n\n设置元素填充颜色。',32,10,NULL,0),(576,'stroke','限定元素:svg内部标签元素\n\n设置元素描边颜色。',32,10,NULL,0),(577,'stroke-width','限定元素:svg内部标签元素\n\n设置元素的边框宽度',32,10,NULL,0),(578,'pt','测量字体字号大小的单位。\npt是绝对长度单位,不会因为屏幕分辨率大小,或其他因素改变。',43,0,NULL,0),(579,'cm','厘米',43,0,NULL,0),(580,'ex','1ex=字母x的高度。',43,0,NULL,0),(581,'LeetCode-练习算法','https://leetcode-cn.com/problemset/algorithms/?difficulty=%E7%AE%80%E5%8D%95',1007,0,NULL,0),(582,'数组动态和','数组动态和的计算公式为:\narr[i]=sum(arr[0]+...+arr[i-1])\n\n示例:\n输入:[1,2,3,4]\n输出:[1,3,6,10]',1043,0,NULL,0),(583,'judge','判断',48,6,NULL,0),(584,'<line>','绘制一条直线。\n\n属性:\nx1,y1：线段起始坐标\nx2,y2：线段终点坐标',1041,0,NULL,0),(585,'<polyline>','绘制一根折线。\n\n属性:\npoints：指定每个端点的坐标,横坐标与纵坐标之间用逗号分隔,多个坐标之间用空格分隔。示例:x1,y1 x2,y2',1041,0,NULL,0),(586,'<rect>','绘制一个矩形。\n\n属性:\nx,y：绘制矩形左上角的坐标\nwidth,height：矩形的大小',1041,0,NULL,0),(587,'<ellipse>','绘制一个椭圆。\n\n属性:\ncx,cy：圆心坐标\nrx：椭圆横向轴的半径\nry：椭圆纵向轴的半径',1041,0,NULL,0),(588,'ellipse','椭圆',48,6,NULL,0),(589,'<polygon>','绘制一个多边形。\n\n属性:\npoints：指定每个端点的坐标,横坐标与纵坐标之间用逗号分隔,多个坐标之间用空格分隔,最后一个坐标将自动与第一个坐标闭合。示例:x1,y1 x2,y2',1041,0,NULL,0),(590,'polygon','多边形',48,6,NULL,0),(591,'polyline','折线',48,6,NULL,0),(592,'<path>','绘制路径。\n\n属性:\nd：绘制顺序。其值格式为action x,y action2 x2,y2\n...\n  action：绘制动作。其值有:\n      M：移动到 \n      L：画直线到 \n      Z：闭合路径(无需参数)\n  x,y：动作移动到的坐标\n\n示例:\n<path d=\"\n  M 18,3\n  L 46,3\n  L 46,40\n  Z\n\"></path>\n\n补充:\n绘制路径时,起始使用M移动画笔是必须的。',1041,0,NULL,0),(593,'<text>','绘制文本。\n\n属性:\nx,y：文本区块基线起点的坐标\n\n示例:\n<text x=\"50\" y=\"25\">Hello World</text>',1041,0,NULL,0),(594,'<use>','复制一个形状。\n\n属性:\nhref：\'#\'+要复制的形状id\nx,y：新形状的左上角坐标\nwidth,height：将复制后的形状缩放到指定值\n\n补充:\n1.可以配合<g>标签实现复合图形复用。\n2.可以配合<defs>标签实现复合图形引用。',1041,0,NULL,0),(595,'<g>','用于将多个形状组成一个组(group),方便复用。\n该标签可包含多个svg绘图标签,并通过use标签实现复合图形复用。',1041,0,NULL,0),(596,'<defs>','用于自定义形状。它内部的代码不会显示，仅供配合<use>标签使用。',1041,0,NULL,0),(597,'<image>','用于插入图片文件。\n\n属性:\n(xlink:href)：图像的地址\nwidth,height：图像的缩放比',1041,0,NULL,0),(598,'<animate>','定义在其他svg内部标签元素以为其添加动画效果。\n\n属性:\nattributeName：发生动画效果的属性名\nfrom：单次动画的初始值\nto：单次动画的结束值\ndur：单次动画的持续时间,单位为s\nrepeatCount：动画的循环模式,可用数字作为值指定循环次数,也可指定值indefinite表示无限循环\nbegin: 动画延时,单位为s\n\n补充:单个<animate>标签可以为外部标签元素添加一个属性的动画效果,若要同时为多个属性添加,则在内部定义多个<animate>标签。',1041,0,NULL,0),(600,'draggable','指定元素是否能被拖动。\n\n值格式:true/false',1026,0,NULL,0),(601,'drag','拖动',48,6,NULL,0),(602,'前言','1.通过设置元素属性draggble=true使元素可以被拖动。\n2.浏览器的默认ondragenter和ondragover行为会拒绝任何元素拖放行为,因此必须先用event.preventDefault()取消浏览器的默认行为。\n',1044,0,NULL,0),(603,'ondragstart','【拖动对象-钩子函数】\n该事件在元素开始被拖动时触发。\n',1044,0,NULL,0),(604,'ondrag','【拖动对象-钩子函数】\n该函数在元素被拖动时反复触发。\n',1044,0,NULL,0),(605,'ondragend','【拖动对象-钩子函数】\n该事件在元素拖动结束时触发。\n',1044,0,NULL,0),(606,'ondragenter','【目标对象-钩子函数】\n被拖动元素进入目标元素占据的屏幕空间时触发,需要取消浏览器的默认行为。',1044,0,NULL,0),(607,'ondragover','【目标对象-钩子函数】\n被拖动元素在目标元素内时重复触发,需要取消浏览器的默认行为。',1044,0,NULL,0),(608,'	ondragleave','【目标对象-钩子函数】\n被拖动元素没有放下就离开目标元素时触发。\n',1044,0,NULL,0),(610,'ondrop','【目标对象-钩子函数】\n当被拖动元素在目标元素里放下时触发，一般需要取消浏览器的默认行为。',1044,0,NULL,0),(611,'event.dataTransfer','在进行拖放操作时，DataTransfer对象用来保存，通过拖放操作，拖动到浏览器的数据。它可以保存一项或多项数据、一种或者多种数据类型。\n\n语法:event.DataTransfer\n以下词条中将建成为dts。',1044,0,NULL,0),(613,'event.preventDefault()','阻止浏览器的默认行为。',58,38,NULL,0),(614,'event.stopPropagation()','阻止事件向外冒泡。\n\n语法:event.stopPropagation()\nevent:可以在通过元素触发事件时通过第一个默认参数event获取到',58,38,NULL,0),(615,'node.cloneNode()','复制一个节点并返回。\n\n语法:node.cloneNode(deep)\ndeep(Boolean):可选。如果传递给它的参数是 true，它还将递归复制当前节点的所有子孙节点。否则，它只复制当前节点。\n\n示例:\nvar itm=document.getElementById(\"myList2\");\nvar cln=itm.cloneNode(true);\ndocument.getElementById(\"myList1\").appendChild(cln);\n该方法将把#myList2元素的节点全都复制到#myList1元素中。',58,21,NULL,0),(616,'dts.setData()','设置拖动操作的当前数据。\n\n语法:dts.setData(format,data)\nformat:拖动数据的MIME类型，通常text/plain和text/uri-list\ndata:要添加的数据\n\n补充:\nformat的类型为text/plain时可以直接通过dts.getData(\"text/plain\");\n但类型为text/uri-list时应该通过dts.getData(\"URL\")来获取;',1044,0,NULL,0),(617,'dts.getData()','获取指定类型的拖放数据。\n\n语法:dts.getData(type)\ntype:指定类型。format的类型为text/plain时可以直接通过dts.getData(\"text/plain\");类型为text/uri-list时应该通过dts.getData(\"URL\")来获取',1044,0,NULL,0),(618,'dts.clearData()','删除当前元素设置的数据。\n一般需要在ondragend方法中使用一次。\n\n语法:dts.clearData(type)\ntype:format的类型为text/plain时可以直接通过dts.getData(\"text/plain\");类型为text/uri-list时应该通过dts.getData(\"URL\")来获取',1044,0,NULL,0),(619,'dts.setDragImage()','使用该方法以定义拖拽时跟随鼠标指针显示的图片。\n\n语法:dts.setDragImage(img,xOffset,yOffset)\nimg:拖拽图像元素,通常是一个image或canvas元素\nxOffset :图片的横向偏移量\nyOffset: 图片的纵向偏移量',1044,0,NULL,0),(620,'dts.dropEffect','该属性设置拖动的效果\n\n可用值:\ncopy:表示拖动的数据将从其当前位置复制到放置位置。\nmove:表示拖动的数据将从其当前位置移动到放置位置。\nlink:表示将在源位置和放置位置之间创建某种形式的关系或连接。\n\n补充:若同时有多个效果,可以用驼峰法将它们连接,如dts.dropEffect=\"copyMove\"',1044,0,NULL,0),(621,'node.replaceChild()','替换一个节点并返回,被替换的节点将被清除。\n\n语法:parent.replaceChild(newNode, oldNode)\nnewNode:要替换为的新节点\noldNode:将被替换的节点',58,23,'2020-07-15',0),(628,'str.conatins()','验证字符串中是否包含了指定字符串,返回布尔值。\n\n语法:str.contains(str2)\nstr2：指定字符串',44,33,NULL,0),(629,'el.addEventListener()','为元素添加监听事件。\n\n语法:el.addEventListener(event,callback,action)\nevent:监听事件,不用加字符串\"on\"\nfunc:监听到时执行的回调函数\naction:该值为false时指示事件冒泡;为true时指示事件捕获。该值默认为false\n\n补充:addEventLinstener()能为对象的同一个事件添加多个响应函数,但若多个响应函数的指向地址相同,则不会被重复添加。',58,5,NULL,0),(630,'event.target','返回当前触发事件的底层子元素。(冒泡)\n与event.currentTarget对应\n\n示例:\n1.html\n<ul>\n  <li><span>点击该元素</span></li>\n</ul>\n\n2.js\nul.addEventListener(\'click\',function(event){\n  console.log(event.target) //=>输出span\n})\n',57,15,NULL,0),(631,'event.currentTarget','返回当前触发事件的元素。(捕获)\n与event.target对应\n\n示例:\n1.html\n<ul>\n  <li><span>点击该元素</span></li>\n</ul>\n\n2.js\nul.addEventListener(\'click\',function(event){\n  console.log(event.currentTarget) \n  //=>输出ul\n})\n',57,14,NULL,0),(632,'pointer-events','设置元素是否响应事件。\n\n可用值:\nauto:默认。正常响应\nnone:元素不会响应任何事件',32,10,NULL,0),(633,'event.relatedTarget','relatedTarget事件属性返回与事件的目标节点相关的节点。\n\n对于 mouseover/dragover 事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。\n对于 mouseout/dragleave 事件来说，该属性是离开目标时，鼠标指针进入的节点。\n对于其他事件,大多数情况下该属性没有作用。',57,13,NULL,0),(634,'改变过程序文件夹位置','改变整个程序文件夹位置后,再次运行会提示包已丢失。\n将整个node_modules文件夹删掉,再次使用cnpm install安装即可解决。\n\n注意该问题在将整个程序文件夹发给其他人后也会出现,因此在发给别人前应自行删掉node_modules,再发给别人让他在运行前先install一下。',1046,0,NULL,0),(635,'drop','放置',48,6,NULL,0),(636,'node.insertBefore()','在节点的某个子节点之前插入一个兄弟节点。\n\n语法:node.insertBefore(node_new,node_child)\nnode_new:要插入的新节点\nnode_child:被插入的子节点',58,31,NULL,0),(637,'node.previousElementSibling','返回节点同级的上一个元素节点。',57,24,NULL,0),(638,'node.previousSibling','返回节点同级的上一个节点。',57,26,NULL,0),(639,'el.hasAttribute()','判断元素是否有指定属性,返回布尔值。\n\n语法:el.hasAttribute(prop)\nprop:属性名',58,1,NULL,0),(640,'el.removeEventListener()','移除元素的指定监听事件。\n\n语法:el.removeEventListener(event,func)\nevent:监听事件\nfunc:要移除的监听事件上的函数\n\n例:\n// func是一个方法\nel.addEventLinstener(\'click\',func)\nel.removeEventListener(\'click\',func)',58,3,NULL,0),(641,'兼容','',1013,0,NULL,0),(642,'基线是什么','',1013,0,NULL,0),(643,'item','项目',48,6,NULL,0),(644,'flex-direction','限定flex元素。\n设置弹性盒的主轴方向。\n\n可选值:\nrow:(默认)主轴方向为从左到右。\nrow-reverse:主轴方向为从右到左。\ncolumn:主轴方向为从上到下。\ncolumn-reverse:主轴方向为从下到上。',32,10,NULL,0),(645,'flex-wrap','限定flex元素。\n设置当弹性盒的内部元素超过其边界时,内部元素如何换行。\n\n可用值:\nnowrap：默认。不换行,超出的元素会显示在弹性元素盒之外\nwrap：正常换行\nwrap-reverse：换行,但行将反向显示(比如原第一行会显示在最下面,原第二行显示在其上一行,以此类推)\n',32,10,NULL,0),(646,'*justify-content','限定flex元素。\n设置内部item主轴方向上的排列方式。\n\n可用值:\nflex-start:起点对齐\nflex-end:终点对齐\ncenter:居中对齐\nspace-between:两端对齐,item间的间隔相等\nspace-around:item间的间隔相等,且两端item的另一侧将保留间隔/2的空间',32,8,NULL,0),(647,'*align-items','限定flex元素。\n设置内部item交叉轴方向上如何排列。\n\n可用值:\nflex-start:起点对齐\nflex-end:终点对齐\ncenter:居中对齐\nstretch:默认。若item未设置宽度或设置为auto,将占满整个容器的高度\nbaseline:项目的第一行文字基线对齐',32,8,NULL,0),(648,'align-content','限定flex元素。\n设置内部多根轴线的对齐方式,若只有一条轴线,则该属性不起作用。\n\n可用值:\nflex-start:起点对齐\nflex-end:终点对齐\ncenter:居中对齐\nstretch:默认。轴线占据整个交叉轴\nspace-between:两端对齐,基线间间隔相等\nspace-around:基线间间隔相等,且两端item的另一侧留有间隔/2的空间',32,8,NULL,0),(649,'order','限定flex-item元素。\n设置项目的排列顺序。\n数字越小,排列越往前。默认为0。\n\n值格式:Number',32,8,NULL,0),(650,'*flex-grow','限定flex-item元素。\n设置项目的放大比例。默认为0。\n\n值格式:Number\n\n示例:\n1.如果弹性盒内部仅有一个项目且其flex-grow值为1,则该项目使用弹性盒的主轴方向所有空间。\n\n2.如果弹性盒内部有1个固定宽度项目,及另一个flex-grow值为1的项目,则该项目使用弹性盒的主轴方向上的剩余空间。\n\n3.如果弹性盒内部有两个flex-grow为1的项目,一个flex-grow为2的项目,则两个flex-grow为1的项目将各自使用弹性盒主轴方向空间的1/4;flex-grow为2的项目将使用弹性盒主轴方向空间的1/2。',32,6,NULL,0),(651,'*flex-shrink','限定flex-item元素。\n设置项目的缩小比例,默认为1。当元素盒空间不足时,该项目将缩小。\n\n值格式:Number\n\n示例:\n  当弹性盒内有a项目缩小比例为0,项目b缩小比例为1,设置它们的宽度为10px。\n  弹性盒的宽度小于20px时,项目a大小保持不变,项目b缩小宽度至可以放下所有元素',32,3,NULL,0),(652,'flex-basis','限定flex-item元素。\n设置弹性盒分配多余空间时,项目占据的主轴空间。浏览器根据这个属性,计算主轴有没有多余空间。\n默认值为auto,即项目的本来大小。\n\n值格式:等同于width/height',32,5,NULL,0),(653,'*flex','限定flex-item元素。\n复合属性,依次指定项目的flex-grow,flex-shrink和flex-basis属性。\n\n补充:优先使用该属性,因为浏览器会推算相关值。',32,7,NULL,0),(654,'*align-self','限定flex-item元素。\n设置项目与弹性盒其他项目不同的交叉轴对齐方式。\n\n可用值:\nflex-start:起点对齐\nflex-end:终点对齐\ncenter:居中对齐\nstretch:默认。若item未设置宽度或设置为auto,将占满整个容器的高度\nbaseline:项目的第一行文字基线对齐',32,9,NULL,0),(655,'banner','广告',48,6,NULL,0),(656,'sub','全写为baisubordinate\n在..下边;在..底部\n一般用作css类前缀以表示一个元素是另一个元素的内部元素\n\n示例:\n<div id=\"nav\">\n  <div id=\"subnav\">\n    //子 导航条\n  </div>\n</div>',48,6,NULL,0),(657,'tip','小技巧',48,6,NULL,0),(658,'guide','指南',48,6,NULL,0),(659,'summary','摘要',48,6,NULL,0),(660,'oriented','面向\n\n例:Object Oriented\n面向对象的',48,6,NULL,0),(661,'layout','布局',48,6,NULL,0),(662,'calc','计算',48,6,NULL,0),(663,'font-smoothing','为元素内字体添加抗锯齿。\n\n可用值:\nnone：不添加抗锯齿。若文本像素较低,可以调成该值。\nsubpixel-antialiased：低像素抗锯齿。\nantialiased：高抗锯齿。',32,19,NULL,0),(664,'虚拟DOM是什么','虚拟dom其实就是一个对象,通过对象+方法的形式将虚拟dom转化为真实dom。',1016,10,NULL,0),(666,'profile','简介',48,6,NULL,0),(667,'GitHub+VSCode','https://www.bilibili.com/video/BV1dK411p7RF?t=258\n看完这个视频就能彻底学会怎么用GitHub代理你的代码,不会Git从没上过gitHub也能直接看,亲测有用!',1007,0,NULL,0),(668,'manage','管理',48,6,NULL,0),(669,'repository','仓库',48,6,NULL,0),(670,'optional','',48,6,NULL,0),(671,'函数的可选参数注释','通常在函数所有可选函数之前添加注释\n/* optional */以表示该参数是可选的。\n\nfunction demo(a,b,/* optional */c){}\n表示c是可选参数。',1016,8,NULL,0),(672,'parameter','参数',48,6,NULL,0),(673,'func.arguments','返回一个Arguments对象。\n该对象包含调用者传入的参数数组和一个callee函数。\n可以通过func.arguments.callee(参数)调用方法本身。',53,0,NULL,0),(677,'使用构造函数需要注意的点','一般通过以下方法为构造函数实例添加通用方法:\nFunc.prototype={\n  constructor:Func,\n  /* 通用方法 */\n}\n此处的constructor是为保留构造函数默认原型中constructor的属性,该属性指向它的对象。\n\n但是需要注意的是,在使用这种方法添加构造函数属性后,若不为其添加不可枚举的构造器属性,constructor将被迭代器遍历到。因此,一般需要在其后添加代码如下:\nObject.defineProperty(Func,\'constructor\',{\n   enumerable:true,\n   value:Func\n})',1016,8,NULL,0),(678,'git clone','复制一份gitHub项目的源码到当前项目中。\n\n语法:git clone 项目地址\n项目地址可以通过gitHub项目右上角的Clone or download下拉框获取。',1050,0,NULL,0),(679,'arr.join()','将数组中的所有元素拼接成字符串,每个元素字符串之间以指定字符分隔。\n\n语法:arr.join(str)\nstr:用来分隔的字符串\n\narr.join()的妙用\n通过eval(arr.join(\'+\'))即可获得数组和,或进行其他数组计算等。',44,47,NULL,0),(680,'原型链和对象继承的方法','要继承的对象示例:\nfunction A(){\n  /* 属性(A) */\n}\nA.prototype={\n  constructor:A,\n  /* 方法(A) */\n}\n\n一、原型继承\n1.示例\nfunction B(){\n  /* 属性(B) */\n}\nB.prototype=new A\n\n2.解释\n利用了原型链,将B的原型对象指向A的一个实例。根据原型链,查找对象上的一个属性/方法时,会遍历它的原型链一级一级往上查找,直到找到对应的属性/方法并返回。\n如示例中,若试图通过B的实例b查找A上的属性,则会按以下顺序进行遍历:b->B.prototype(A的实例),此时在A的实例上找到了对应的属性,返回该值。\n若视图通过B的实例查找A上的原型方法,则会按以下顺序进行遍历:b->B.prototype(A的实例)->A.prototype,此时在A的原型对象上找到了对应的方法,返回该值。\n\n3.弊端\n如果要继承的属性有引用类型的对象(如数组等),在继承时继承的是对应的数组地址,也就是说,你在任何B的实例中改变数组,都会同时影响到所有的B实例数组。\n\n二、call继承\n1.示例\nfunction B(){\n  A.call(this)\n  /* B的属性 */\n}\nB.prototype={\n  constructor:B,\n  /* B的方法 */\n}\n\n2.解释\n利用了构造函数的特性。\n构造函数中的方法,会在通过new被创建实例时,返回一个新的对象,并用这个对象去执行自身内部的方法,比如:\nfunction demo(){\n  this.test=1\n}\nvar d=new demo()\nconsole.log(d.test) //=>1\n这看起来似乎没什么稀奇,但是你有没有想过,构造函数中的this指向的是谁?\n一般情况下,普通函数内部的this指向的是全局对象,也就是浏览器环境下的window。但当函数是以new()被调用时,内部的this就指向了要创建的新对象。\n明白了这点,就知道A.call(this)这句话,其实表示的就是以b的实例执行A构造函数内部语句,那么就会将A构造函数内部的属性获取全部执行一遍,自然就获得了A的所有属性。\n\n3.弊端\n这种继承方式不会继承A的原型方法,理由很简单,你只是让b的实例借用A的构造函数执行了一下而已,根本就没获取过它的原型。\n这一点是十分致命的,若你把方法直接执行在A构造函数中,那么又回到了原型继承中每次创建实例都要开辟内存空间来存放重复方法的问题...\n\n三、组合继承\n1.示例\nfunction B(){\n  A.call(this)\n  /* 属性(B) */\n}\nB.prototype=new A\n\n2.解释\n集合了原型继承和call继承两种方法,充分的利用了原型链,这也是比较常用的方法。\n首先,将B的原型指向了A,这样就能在原型链上获取到A的属性和原型上的方法。当然,在分析原型继承的缺点时说过,这种方法的缺点就是当A的属性为引用类型时,修改这个属性会同时修改所有B的实例上的属性。\ncall继承便解决了这一缺点,它的属性存放在实例本身,而非原型对象上,自然也就不用担心引用类型属性的问题。\n那么结合之前说过的原型链特性,读取一个属性时会顺着原型链一层一层往上找,并返回第一个找到的属性,那么也就是说。\n当call和原型继承同时使用时,实例上的属性和原型对象上的属性同时存在,但是读取某个属性时,会先从实例本身的属性开始找,已经找到了,就不再去原型链下一层找,这就是组合继承的优势。\n\n3.弊端\n继承的属性会在实例本身和其原型中出现两次,导致易读性不佳。\n\n可以看出,组合继承也是一种相当实用的继承方法。instanceof【判断属性/方法是不是在对象原型链上】和isPrototypeOf()【判断属性/方法是不是对象的私有属性】也能够用于识别基于组合继承创建的对象。\n\n四、冒充对象继承\n1.示例\nfunction B(){\n  var o=new A\n  for(let key in o){\n    this[key]=o[key] \n  }\n  o=null\n}\nB.prototype={\n  constructor:B,\n  /* B的方法 */\n}\n\n2.解释\n这个方法利用了for..in..的特性,for..in..会遍历目标包括其原型上的所有属性和方法。\n因此使用一个临时对象o来获取A的实例,并遍历其属性和方法将其赋给B的实例,之后再将这个对象回收(置为null)\n这种方法的好处在于,相比组合继承,它不需要用到继承对象的原型,你可以为每个继承的对象原型添加其独立的方法。\n\n3.弊端\n①冒充对象继承的优势很明显,弊端也相应的非常明显,既然不需要使用继承对象的原型,你就难以通过instanceOf和isPrototypeOf()来判断某个属性继承自父类还是自己本身有的属性。\n②会将父类原型上的constructor属性也拷贝到自身上来,当然这可以通过筛选避免。\n\n',1016,8,'2020-07-01',0),(681,'500','后台服务器错误。',1051,0,NULL,0),(686,'404','请求的接口地址不存在,也可能是请求方式(get,post)出现了问题。',1051,5,NULL,0),(687,'插入排序','1.思路\n其核心思想是:将arr[0]作为默认第一项,然后遍历arr[1]开始的数组每一项与从后往前与已经排序好了的每一项分别比较。\n若当前遍历项小于比较的元素,将当前遍历项插入比较的元素之前。\n\n2.示例\nfunction sort(arr){\n  var temp\n  // 遍历arr数组的每一项\n  for(let i=1;i<arr.length;i++){\n    // 遍历已排序元素的每一项\n    temp=arr[i]\n    i_copy=i\n    for(let n=i-1;n>=0;n--){\n      if(arr[i_copy]<arr[n]){\n        arr[i_copy]=arr[n]\n        arr[n]=temp\n      }\n      i_copy--\n    }\n  }\n  return arr\n}',1054,0,NULL,0),(688,'temp','临时\n\n常在编程语言中表示临时变量。',48,6,NULL,0),(689,'冒泡排序','1.思路\n将数组从第一位到数组末位的元素进行遍历,每次遍历使对应下标元素开始的元素依次与其后相邻的元素进行比较,若下标小的元素比其相邻下标大的元素值大,交换它们的位置。\n因为随着比较的进行,较小位数会逐渐浮现在数组低位,因此被叫做冒泡排序。\n\n2.示例\nfunction sort (arr) {\n  let flag = false\n  for(let i=0;i<arr.length;i++){\n    for(let n=0;n<arr.length-i-1;n++) {\n      if (arr[n]>arr[n + 1]){\n        [arr[n],arr[n+1]]=[arr[n+1],arr[n]]\n        flag = true\n      }\n    }\n    if (!flag) {\n      break\n    }\n    flag = false\n  }\n  return arr\n}',1054,0,NULL,0),(690,'flag','标记\n\n在程序中常用来表示一个布尔值。',48,6,NULL,0),(691,'str.slice()','一、概述\n该方法用以截取字符串中的一部分\n\n二、语法\nstr.slice(start,end)\n-start:开始截取的字符串下标\n-end:结束下标+1\n',44,26,'2020-07-08',0),(692,'200','服务器已经成功接受请求，并将返回客户端所请求的最终结果。',1051,9,NULL,0),(693,'202','表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定。',1051,8,NULL,0),(694,'204','服务器成功处理了请求，但没有返回任何实体内容 ，可能会返回新的头部元信息。',1051,7,NULL,0),(695,'301','客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果。',1051,6,NULL,0),(696,' 503','服务器由于临时的服务器过载或者是维护，无法解决当前的请求。',1051,0,NULL,0),(697,'Math.ceil()','将Number类型的值向上取整。\n\n例:Math.ceil(3.5) //=>4',44,8,NULL,0),(698,'basic','基本的\n\nbasic point基点',48,6,NULL,0),(699,'快速排序(二分法)','1.思路\n即选择一个数组的基准点(一般是下标为Math.foor(数组长度/2)的数组元素),将数组中小于该基准点的元素放到数组左边,将大于该基准点的元素放到数组右边,然后分别对数组左右两侧递归执行。\n\n2.示例\nfunction sort (arr) {\n  var arrLen = arr.length\n  if (arrLen <= 1) { return arr }\n  \n  // 获取基准点\n  var basicindex = Math.floor(arr.length / 2)\n  var basicpoint = arr.splice(basicindex, 1)\n  // 此处要注意!arr的长度变量未变化,要手动-1\n  arrLen-=1\n  \n  // 通过与基准点比较获取数组左半部分和右半部分\n  var left = []\n  var right = []\n  for (let i = 0; i < arrLen; i++) {\n    if (arr[i] < basicpoint) {\n      left.push(arr[i])\n    }\n    else right.push(arr[i])\n  }\n  \n  // 遍历计算返回\n  return sort(left).concat(basicpoint, sort(right))\n}',1054,0,NULL,0),(700,'repeat','重复',48,6,NULL,0),(701,'数组去重','去除数组中重复部分并返回。\n\n方法一：\n1.思路\n每一次拿出数组中的当前项和后面的所有项进行比较，如果相同的话，删除即可\n\n2.示例\nfunction deleteRepeat (arr) \n{\nfor(let i=0,arrLen=arr.length;i<arrLen;i++) \n {\n    for (let n = i + 1; n < arrLen; n++) \n    {\n      if (arr[i] === arr[n]) {\n        arr.splice(n, 1)\n        arrLen--\n        n--\n      }\n    }\n  }\n}\n\n方法二：\n1.思路\n利用对象键的特性,创建一个空对象并遍历数组每一项,若对象中不存在对应数组值的键名,将其值存储入对象键值中,同时删除数组的对应元素。\n\n2.示例\nfunction deleteRepeat (arr) {\n  var obj = {}\n  for (let i = 0, arrLen = arr.length; i < arrLen; i++) {\n    if (typeof obj[arr[i]] !== \'undefined\') {\n      arr.splice(i, 1)\n      i--\n      arrLen--\n    }\n    else {\n      obj[arr[i]] = 1\n    }\n  }\n  obj = null\n  return arr\n}',1054,0,NULL,0),(702,'随机获取不重复数','1.思路\n用一个数组包含所有可获取到的数,然后随机获取最大值它的数组长度的数字,将对应数字下标的数组元素添加到要返回的数组中,并把数组的对应数值下标元素删掉。\n\n2.示例\n// 生成指定长度数组,数组的每一位由随机且不重复的数填充\nfunction createNewArr (length) {\n  // 如果要生成的数组长度大于随机数字的最大值,返回null\n  var max = 30\n  if (length>max) { return null }\n\n  var arr = []\n\n  // 初始化随机数数组\n  var randarr = []\n  for (let i = 0; i < max; i++) {\n    randarr[i] = i\n  }\n\n  // 随机生成返回数组\n  for (let i = 0; i < length; i++) {\n    // 获取从随机数数组中要提取的下标\n    let index = Math.floor(Math.random()*max)\n    arr.push(randarr[index])\n    randarr[index] = randarr[max - 1]\n    randarr.length -= 1\n    max--\n  }\n\n  return arr\n}',1054,0,NULL,0),(703,'判断浏览器是否为IE9-','getElementsByClassName在IE6、7、8中是不存在的,因此可以通过判断document中有没有这个方法以判断浏览器是否为低版本IE浏览器。\n\n示例:\"getElementsByClassName\" in document\n该语句将返回一个布尔值以判断当前浏览器是否为低版本IE浏览器。',1056,0,NULL,0),(706,'location.hash','设置或获取地址的锚点(即#之后跟的地址)',55,2,NULL,0),(707,'location.origin','获取地址',55,2,NULL,0),(708,'node.nodeName','对于元素节点,该属性返回节点标签名(全大写)。\n对于其他节点,该属性返回#+节点名。\n一般使用该值以获取元素节点的标签名。\n\n示例:\n<span></span>\nvar span=document.querySelector(\'span\')\nconsole.log(span.nodeName)\n//=>输出\'SPAN\'\n\n补充:由于该属性依赖于节点的类型,应在使用前对节点的类型进行检测。',57,32,NULL,0),(709,'node.nodeValue','返回节点的文本值。\n该属性只对Text节点(3),字符数据节点(4),注释节点(8)有效。\n对于其他节点,返回null。\n\n示例:\n<div>111</div>\nvar div = document.querySelector(\'div\')\nconsole.log(div.childNodes[0].nodeValue)\n//=>输出111\n\n补充:由于该属性依赖于节点的类型,应在使用前对节点的类型进行检测。',57,32,NULL,0),(710,'node.nodeType','该属性用来检测节点的类型,返回值类型为Number,每个数字对应一个节点类型。\n\n对应值:\n/* 以下为常用的 */\n1:元素节点\n3:文本节点(标准浏览器中会把元素节点间的空格和换行符也当成文本节点)\n8:注释节点\n9:文档节点(即dom树的根节点)\n\n/* 以下为基本用不到的,可以了解一下 */\n2:属性节点\n4:字符数据节点(文本不会被解析器解析)\n5:实体应用节点\n6:实体节点\n7:处理指令节点\n10:向为文档定义的实体提供接口\n11:表示邻接节点和它们的子树\n12:代表一个符号在DTD中的声明',57,33,NULL,0),(714,'preventDefault()引发的错误','一、报错背景说明\n1.设置了keydown的回车键触发其他事件并禁用了它的默认事件。\n2.编辑文本时,使用回车键换行,发送到后台的文本为未换行之前的文本。\n\n二、结论\nkeydown中使用preventDefault()会阻止v-model的双向绑定事件。\n\n三、最终解决的过程\n1.在将数据发送至后台前,查看文本框dom元素的内容,为正常换行。\n2.查看发送向后台的数据,发现发送数据时使用的并非使用文本框dom元素的内容。\n3.发现发送至后台的数据使用了v-model双向绑定,判断出v-model没有及时更新数据。\n4.判断出v-model的双向绑定事件被keydown中的preventDefault()事件所阻止。\n5.在keydown事件中阻止默认行为的语句前加上使双向绑定数据手动更新,问题解决。\n',1058,0,NULL,0),(715,'desination','目标',48,6,NULL,0),(716,'port','端口',48,6,NULL,0),(717,'protocol','协议',48,6,NULL,0),(718,'capture','抓包',48,6,NULL,0),(719,'follow','根据',48,6,NULL,0),(720,'stream','流',48,6,NULL,0),(721,'BOM','BOM是Browser Object Model的缩写，即浏览器对象模型。\nBOM提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本，对Cookie的支持。\n\nBOM没有相关标准，因此不同的浏览器实现同一功能，可能通过不同的实现方式。\n\n虽然BOM没有一套标准，但是各个浏览器的常用功能的JavaScript代码还是大同小异的，对于常用的功能实际上已经有默认的标准了。所以不用过于担心浏览器兼容问题，不是每个浏览器都有自己的BOM，也不需要为每个浏览器都学习一套BOM，只是个别浏览器会有新增的功能会在BOM上体现出来。',1014,0,NULL,0),(722,'DOM','DOM是Document Object Model的缩写，即文档对象模型。\nDOM是针对XML的基于树的API。描述了处理网页内容的方法和接口，是HTML和XML的API，DOM把整个页面规划成由节点层级构成的文档。DOM本身是与语言无关的API，它并不与Java，JavaScript或其他语言绑定。\n\nDOM是W3C的标准。',1014,0,NULL,0),(723,'setInterval()','每隔一段指定时间异步执行回调函数\n\n语法:setInterval(callback,time,...paras)\ncallback:执行的回调函数\ntime:间隔时间,以毫秒为单位\nparas:可选。要传递给回调函数的参数\n\n示例:setInterval(function(){\n   console.log(111)\n},1000)\n// 以上代码使控制台每秒输出一次111',56,0,'2020-07-10',0),(724,'clearInterval()','清除一个已定义的循环计时器。\n\n语法:clearInterval(timer)\ntimer:使用setInterval方法创建的计时器对象。\n\n补充:若希望使用该方法清除计时器,需要在定义计时器时间计时器赋值给一个变量。\nvar a=setInterval(function(){\n   console.log(111)\n},1000)\nclearInterval(a)\n',56,0,'2020-07-04',0),(725,'node.firstChild','返回节点的第一个子节点。',57,28,NULL,0),(726,'node.lastChild','返回节点的最后一个子节点。',57,28,NULL,0),(727,'node.nextSibling','返回节点同级的下一个节点。',57,28,NULL,0),(728,'node.nextElementSibling','返回节点同级的下一个元素节点。',57,27,NULL,0),(729,'node.parentNode','返回节点的父级节点。',57,29,NULL,0),(730,'node.appendChild()','在节点的最后一个子节点之后插入目标节点。\n\n语法:node.appendChild(node_insert)\nnode_insert:要插入的目标节点',58,32,NULL,0),(731,'node.removeChild()','移除节点的目标子节点。\n\n语法:node.removeChild(node_child)\nnode_child:要删除的目标子节点',58,24,NULL,0),(732,'node.hasChildNodes()','检测节点是否有指定子节点,返回布尔值。\n\n语法:node.hasChildNodes(node_child)\nnode_child:目标子节点',58,20,NULL,0),(747,'node.childNodes','类数组,该属性保存了节点的所有子节点集合。\n\n注意:由于在标准浏览器中,元素节点间的换行和空格被视为文本节点,因此一般避免或过滤以使用该属性。\n<div>\n  <p></p>\n  <p></p>\n</div>\n//=>此时div.childNodes能获取到的数组为\n//[text.p,text,p,text]',57,31,NULL,0),(751,'document.write()','将字符串写入当前文档流。\n\n语法:document.write(str)\nstr:要写入的字符串\n\n注意:该事件若在页面加载后调用,会在执行前自动触发document.open()方法。',58,20,NULL,0),(752,'document.writeIn()','将字符串写入当前文档流,并在末尾加一个换行符。\n\n语法:document.writeIn(str)\nstr:要写入的字符串\n\n注意:该事件若在页面加载后调用,会在执行前自动触发document.open()方法。',58,20,NULL,0),(754,'document.open()','打开一个要写入的文档。\n将导致:\n1.页面上的节点全部被清除\n2.页面上的所有事件监听器被清除',58,20,NULL,0),(755,'document.close()','关闭一个页面在写入的文档。',58,20,NULL,0),(757,'document.title','设置或获取文档的标题。',57,20,NULL,0),(758,'document.URL','设置或获取完整地址。',57,20,NULL,0),(759,'document.domain','设置或获取域名。',57,18,NULL,0),(760,'document.referrer','返回来源页面的完整URL。',57,18,NULL,0),(761,'title','悬停在元素上时会显示title的内容',31,0,NULL,0),(762,'dir','元素内容文本的方向。\n\n可选值:\nltr:从左到右\nrtl:从右到左',31,0,NULL,0),(763,'el.getAttribute()','获取元素指定属性值。\n\n语法:el.getAttribute(attrKey)\nattrKey:属性名',58,0,NULL,0),(764,'el.setAttribute()','设置元素的指定属性值。\n\n语法:el.setAttribute(attrKey,val)\nattrKey:属性名\nval:要修改为的值',58,0,NULL,0),(765,'el.removeAttribute()','移除对象的指定属性,并彻底使其失效。\nIE6不支持该属性。\n\n语法:el.removeAttribute(attrKey)\nattrKey:要移除的属性名',58,0,NULL,0),(766,'document.createElement()','创建一个新元素。\n\n语法:document.createElement(tag)\ntag:要创建的元素标签名\n\n注意:创建的元素是游离元素,需要手动添加到文档流中。',58,11,NULL,0),(767,'fragment','碎片',48,6,NULL,0),(768,'document.createDocumentFragment()','创建一个文档碎片。\n\n语法:document.createDocumentFragment()\n\n在大量向文档中添加新元素时,可以把新元素都统一插入fragment元素的子节点中,再将这个fragment元素添加入元素节点,这是一种节约性能的方法。\n\n示例:\n<ul id=\"myList\"></ul>\n<script>\n    var fragment = document.createDocumentFragment();\n    var oUl = document.getElementById(\"myList\");\n    var li = null;\n    for (var i=0; i < 300; i++){\n        li = document.createElement(\"li\");\n        li.appendChild(document.createTextNode(\"Item \" + (i+1)));\n        fragment.appendChild(li);\n    }\n    oUl.appendChild(fragment);\n</script>',58,10,NULL,0),(769,'*document.createTextNode()','创建一个文本节点。\n\n语法:document.createTextNode()',58,9,NULL,0),(770,'el.normalize()','合并节点的所有文本子节点。\n\n语法:el.normalize()',58,0,NULL,0),(771,'el.splitText()','按照指定位置分割文本节点。\n分割后的左侧文本节点将替代原文本节点,右侧文本节点将作为方法返回值返回。\n\n语法:var right=el.splitText(textNode)\nright:分割后的右侧文本节点\ntextNode:要分割的文本节点',58,0,NULL,0),(772,'el.clientWidth','获取元素的内部宽度,包含内边距,但不包含垂直滚动条,边框和外边距。',57,47,NULL,0),(773,'el.clientLeft','获取元素的左边框宽度。',57,51,NULL,0),(774,'el.offsetWidth','获取元素总宽度。包括width+内边距padding+边框宽度border+垂直滚动条宽度。',57,39,NULL,0),(775,'el.offsetHeight','获取元素总高度。包括height+内边距padding+边框宽度border+水平滚动条宽度。',57,38,NULL,0),(777,'el.offsetParent','获取元素的上级参照物(即上一个非默认position定位的祖父元素)',57,59,NULL,0),(778,'el.offsetLeft','返回元素距离其上级参照物左侧顶端的距离。\n\n上级参照物:即上一个非默认position定位的祖父元素',57,58,NULL,0),(779,'el.scorllLeft','返回元素滚动位置相对于元素内部左侧顶端的距离。',57,55,NULL,0),(780,'el.scrollWidth','获取元素实际内容的宽度。\n若内容宽度未溢出,该值等同于el.clientWidth。\n若内容宽度溢出,该值等同于内容的宽度。',57,43,NULL,0),(781,'el.scrollHeight','获取元素实际内容的高度。\n若内容高度未溢出,该值等同于el.clientHeight。\n若内容高度溢出,该值等同于内容的高度。',57,42,NULL,0),(782,'el.getBoundingClientRect()','返回一个矩形对象。\n该对象包含4个属性:left,top,right,bottom,分别对应元素相对于页面四个方向的位置。\n\n兼容:IE6,7,8中默认文档的左上角坐标为(2,2),而其他浏览器的左上角坐标为(0,0),因此若希望兼容低版本IE需要自行兼容。',57,37,NULL,0),(783,'event对象兼容','在IE下的事件对象,是一个全局的event,因此在使用event时一般要写成:\nevent=event||window.event\n以保证IE兼容。',1056,0,NULL,0),(784,'event.offsetX','返回鼠标基于其所在元素的上级参照物左侧顶端的距离。\n\nfirefox浏览器不兼容该属性。',57,5,NULL,0),(785,'event.offsetY','返回鼠标基于其所在元素的上级参照物顶端的距离。\n\nfirefox浏览器不兼容该属性。',57,4,NULL,0),(786,'event.clientX','返回鼠标基于当前浏览器窗口可视区域左侧顶端的距离。',57,8,NULL,0),(787,'event.clientY','返回鼠标基于当前浏览器窗口可视区域顶端的距离。',57,8,NULL,0),(788,'event.screenX','返回鼠标相对于屏幕左侧顶端的距离。',57,0,NULL,0),(789,'event.screenY','返回鼠标相对于屏幕顶端的距离。',57,0,NULL,0),(790,'event.type','返回当前触发事件的类型(如click,mouseover等)',57,17,NULL,0),(791,'event.pageX','返回鼠标相对于文档左侧顶端的距离(包括滚动条已滚动部分)',57,7,NULL,0),(792,'event.pageY','返回鼠标相对于文档顶端的距离(包括滚动条已滚动部分)',57,6,NULL,0),(794,'mouseover','鼠标悬停在元素上时持续触发。\n该事件会传播。',1068,1,NULL,0),(795,'mouseenter','鼠标进入元素时触发。\n该事件不会传播。',1068,2,NULL,0),(796,'mouseout','鼠标离开元素时触发。\n该事件会传播。',1068,0,NULL,0),(797,'AST抽象语法树','全称:Abstract Syntax Tree\nAST是源代码的一种抽象表达形式,任何代码在编译时都将转换为AST的形式以被系统解析运行。\n如以下javascript代码:\nfunction add(a,b){\n  return a+b\n}\n会解析为:\n{\n  name:\'add\',\n  type:\'identifier\',\n  params:[\n    {\n      name:\'a\',\n      type:\'identifier\'\n      ...\n    },\n    {\n      name:\'b\',\n      type:\'identifier\'\n      ...\n    }\n  ],\n  body:{\n    ...\n  }\n}',1014,0,NULL,0),(798,'selectionStart','设置或返回用户选中的文本选区开始位置。\n\n限定元素:文本框元素',1026,0,NULL,0),(799,'selectionEnd','设置或返回用户选中的文本选区结束位置。\n\n限定元素:文本框元素',1026,0,NULL,0),(801,'base','基础',48,6,NULL,0),(802,'internal','内部',48,6,NULL,0),(803,'reference','参考',48,6,NULL,0),(804,'environments','环境',48,6,NULL,0),(805,'semantic','语义的',48,6,NULL,0),(806,'version','版本',48,6,NULL,0),(807,'optimization','优化',48,6,NULL,0),(808,'stand-in','替代',48,6,NULL,0),(809,'memoize','记住',48,6,NULL,0),(810,'cache','缓存',48,6,NULL,0),(814,'str.toLowerCase()','将字符串中所有大写字母转化为小写字母后,将新字符串返回。',44,25,NULL,0),(815,'str.toUpperCase()','将字符串中所有小写字母转化为大写字母后,将新字符串返回。',44,24,NULL,0),(816,'console.time()','测试用方法,用于计算一段代码完成需要多长的时间。开始计时。\n\n语法:console.time(flagstr)\nflagstr:标志用字符串,停止计时需要传入相应的字符串',44,148,NULL,0),(817,'console.timeEnd()','测试用方法,用于计算一段代码完成需要多长的时间。结束计时并返回经过的毫秒数。\n\n语法:console.timeEnd(flagstr)\nflagstr:标志用字符串,开始计时所输入的相应字符串',44,147,NULL,0),(818,'Number.parseInt()','将指定值转换为整型数字。\n若该值为浮点数,则总是往下取整。\n若该值无法转换为数字,返回NaN。',44,3,'2020-07-06',0),(819,'Number.parseFloat()','将指定值转换为浮点数。\n将字符串转为浮点数,会提取字符串左侧的数值进行转换(如\'12a44\'会转化为12),但若左侧没有数字,返回NaN(如\'a1244\'会转化为NaN)',44,2,'2020-07-06',0),(820,'假值','false,0,\'\',null,undefined,NaN',1016,12,'2020-07-07',0),(821,'compact','严谨,紧凑',48,6,NULL,0),(824,'AMD规范','AMD(异步模块定义)是为浏览器环境设计的规范,它只有一个接口。\n\n即define(id?: String, dependencies?: String[], factory: Function|Object)\nid:模块导出名,可省略。若省略该参数,则表示以文件路径本身作为模块导出名。\n\ndependencies:依赖模块,每一个数组元素保存一个依赖模块地址或名字,可省略。\n\nfactory:模块的具体实现,它可以是一个函数或对象。当它为函数时,表示回调函数,参数名须指定需要使用已导入模块的名字;当它为对象时,表示导入数据,类似于json的格式。\n\n但需要注意,AMD只是一种规范,而require.js便是依赖了AMD规范将其实现,若希望以这种方式写模块化代码可以依赖该库。\n\n',1016,4,NULL,0),(825,'flat','扁平',48,6,NULL,0),(826,'arr.flat()','该方法将按照一个可指定的递归深度遍历数组,并将遍历到的所有元素和遍历到的子数组中的元素合成为一个新数组并返回,这个过程也称为数组扁平化。\n\n语法:arr.flat(deep)\ndeep:遍历深度,可指定为Infinity,若不指定,默认为1\n\n示例:\n①[1,2,3,[4,[5,6]]].flat()\n//=> [1,2,3,4,[5,6]]\n②[1,2,3,[4,[5,6]]].flat(2)\n//=> [1,2,3,4,5,6]\n\n补充:\n该方法将移除数组中的空项。(非空值)\n\n兼容:\nIE浏览器和一些低版本的浏览器不支持该属性,可以使用其他方法进行兼容。\n比如使用arr.concat与apply的特性:\n[].concat.apply([],arr)\n// 等同于一层扁平化\n',44,45,NULL,0),(827,'正则表达式入门','https://www.bilibili.com/video/BV1mW411i7C4?p=1\n老师讲的比较有趣也通俗易懂。\n但注意这个没讲通配符,自行了解。',1007,0,NULL,0),(830,'.','匹配除行终止符外的任意字符。\n\n行终止符包括有:\nU+000A 换行符（\\n）\nU+000D 回车符（\\r）\nU+2028 行分隔符（line separator）\nU+2029 段分隔符（paragraph separator）',50,6,'2020-07-06',0),(831,'\\w','匹配数字、字母和下划线。\n\n等同于[a-zA-Z0-9_]',50,6,'2020-07-05',0),(832,'\\s','匹配空白字符。',50,6,NULL,0),(833,'\\d','匹配数字。',50,6,NULL,0),(834,'\\b','匹配行的开始或结束',50,6,NULL,0),(835,'^','匹配行的开始。\n\n出现在[]开头时,表示匹配否定,即将匹配结果取反。',50,0,NULL,0),(836,'$','匹配行的技术',50,0,NULL,0),(837,'[abc]','匹配方括号中任意一个字符。\n\n可以使用[0-9]表示任意数字。\n可以使用[a-z]表示任意小写字母。\n可以使用[A-Z]表示任意大写字母。\n\n可以使用unicode编码来表示一个区间。\n如:[\\u4e00-\\u9fa5]表示任意中文字符\n\n[]内部开头使用^时,表示匹配否定,即将匹配结果取反。',50,0,NULL,0),(838,'+','匹配前面的字符1到无限次。',50,0,NULL,0),(839,'*','匹配前面的字符0到无限次。',50,0,NULL,0),(840,'?','匹配前面的字符0到1次。',50,0,NULL,0),(841,'{n,m}','匹配前面的字符n到m次。\n\n若忽略第二个参数写成{n},表示匹配前面的字符n次\n\n若第二个参数留空写成{n,},表示匹配前面的字符n到无限次。',50,0,NULL,0),(842,'(表达式)','分组符。\n可以使用|表示匹配的‘或’,如(a|b)表示匹配a或b字符。\n可以将表达式匹配到的结果保存,使其能够在下次使用正则表达式时通过$+序列号直接调用。\n\n例:\n\'王二狗拉拉\'.replace(/(.*)拉拉/,\'$1傻傻\')\n//=> 将被替换为\'王二狗傻傻\'',50,0,NULL,0),(843,'(?:表达式)','匹配表达式但不保存匹配结果。',50,0,NULL,0),(844,'reg.test()','检测指定字符串是否符合正则表达式。\n\n语法:reg.test(str)\nstr:要检测的指定字符串\n',44,13,NULL,0),(845,'str.replace()','替换字符串中符合正则表达式的部分为指定字符串并返回。\n\n语法:str.replace(reg,repstr)\nreg:要匹配的正则表达式\nrepstr:要替换为的字符串',44,32,NULL,0),(846,'正则表达式图形化工具','https://regexper.com/',1007,0,NULL,0),(847,'reg.source','获取包含正则表达式的字面量表示的字符串。\n\n例:console.log(/abc/g.source)\n//=>输出\'/abc/g\'',53,0,'2020-07-05',0),(849,'\\uNNNN','匹配一个unicode码为NNNN的字符。\n\n示例:\\u4e00指代中文字符\'一\'',50,0,NULL,0),(850,'\\xNN','匹配一个ASCII码16进制编码为NN的字符。\n\n示例:\\x20匹配的是ASCII编码\' \'空白字符',50,0,NULL,0),(851,'你不知道的Js(上卷)','他人推荐。\n引用:这本书我是相见恨晚，上卷把作用域讲解的非常透彻，包括函数作用域，作用域提升，闭包等；和JavaScript高级程序相关内容比对着看会理解的比较透，再在实践中运用几次这部分知识基本上就掌握了；当然上卷还讲了对象，原型等知识，都写的很不错推荐精读；\n',46,0,'2020-07-04',1),(852,'JavaScript设计模式','他人推荐。\n引用:\n这个名字的书有两本推荐都买了和JavaScript高级程序设计中继承部分的内容比较着看；\n\n推荐先看国内作者张容铭写的这本，因为这本书写了很多目前常用的设计模式，如何用JS模拟类，模拟继承，多态以及常用的设计模式等；\n\n再说国外作者Addy osmani的这本，最好和另一本比对着看，这样有助于理解的更深刻',46,0,'2020-07-04',1),(853,'深入理解计算机系统','他人推荐。\n引用:\n如果时间充裕的话我个人推荐看深入理解计算机系统，虽然这本书看似与前端关系不大，不过看完它你应该会有醍醐灌顶之感',46,0,'2020-07-04',1),(854,'Web性能权威指南','他人推荐。\n引用:\n这本书很推荐，写了很多常用的优化技术，我个人比较喜欢关于无线网络，移动网络部分，因为其它书中很少涉及(另外如果喜欢TCP，UDP等协议有时间可以看看Unix网络编程)',46,0,'2020-07-04',1),(855,'iterator','迭代器',48,6,NULL,0),(856,'回到上一个光标位置','alt+← 回到上一次浏览时光标所在的文档位置\nalt+→ 相反',1038,0,NULL,0),(857,'Array.isArray()','判断对应值是不是数组,返回布尔值。\n\n语法:Array.isArray(val)\nval:要判断的值',44,6,NULL,0),(858,'深拷贝和深比较','一般情况下,想要复制一个对象时,如果像obj1=obj2这么做,obj1改变时obj2也会同样发生改变,因为对象中保存的是内存地址,而=只是把对象的内存地址复制了过去而已,这个叫做浅拷贝。\n\n而深拷贝指的是,遍历对象中的所有子对象,将每一个对象中的键值和子对象的键值都拷贝到新对象中,这样就不会只是拷贝内存地址了。\n\n相对应的,深比较指的就是遍历两个对象中的所有子对象,对每一个对象中的对应键值和子对象的键值都进行比对,而不是单纯比较对象地址。只要有一项不相等,就认为它们不相等。',1016,4,NULL,0),(859,'区分对象基本/引用数据类型','typeof方法对于引用数据类型,统一返回object。\n若希望获取引用数据类型的具体数据类型(Array)等,可以使用{}.toString.call(要判断的数据)',1016,4,NULL,0),(860,'数组扁平化','指将一个多维数组根据某个给定深度压缩为低维数组。\n如[1,2,3,[4,[5,6]]]扁平化深度1后为[1,2,3,4,[5,6]]\n而扁平化深度2后为[1,2,3,4,5,6]\n\n可以通过arr.flat()方法实现数组扁平化。',1016,4,NULL,0),(861,'comparator','比较器',48,4,NULL,0),(862,'path','路径,映射',48,4,NULL,0),(863,'libs','库',48,2,NULL,0),(865,'监听对象属性值发生变化','通过代理构造函数Proxy或监听对象的get事件Object.defineProperty()实现',1016,4,NULL,0),(869,'开闭原则','指原有类可扩展,但不可修改已有的方法。',1016,3,NULL,0),(872,'keyboard','键盘',48,2,NULL,0),(873,'Object.assign()','es6方法。\n该方法用于为传入的第一个对象添加其后对象的所有自身属性,并返回传入的第一个对象,拷贝方法为浅拷贝。\n\n语法:Object.assign(target,...source)\ntarget:目标对象\nsource:来源对象\n\n注意:\n1.若传入的对象有同名属性,后面添加的对象属性会替代之前的对象属性。\n2.该方法不会拷贝对象的继承属性以及不可枚举的属性。\n3.该方法不会复制对象的存取器属性上的读写操作,只会复制属性的值,若希望完整复制对象属性的赋值操作和取值方法,可以将Object.getOwnPropertyDescriptors()和Object.defineProperties()配合使用打成这种效果,如:\nObject.defineProperties(target, Object.getOwnPropertyDescriptors(source))\n',44,94,'2020-07-07',0),(875,'单例模式','一、概念\n又称为Singleton模式。\n指整个类只有一个实例,在类的内部生成该示例并向整个系统提供这个实例。\n\n二、示例\nfunction Test () {\n  var _instance = null\n  function _module (id) {\n    this.id = id\n  }\n  return {\n    getInstance (id) {\n      if (!_instance) {\n        _instance = new _module(id)\n      }\n      return _instance\n    }\n  }\n}\nvar t = new Test()\nvar m1 = t.getInstance(1)\nconsole.log(m1.id)// =>1\nvar m2 = t.getInstance(999)\nconsole.log(m2.id)// =>1\nm2.id=2\nconsole.log(m1.id)// =>2\n\n三、解析\n可以注意到,只有第一次创建的_module实例成功的传入了值,之后再次创建的实例没有成功创建,而是返回了第一次创建的实例。\n以上就是单例模式的基本原理,这种设计模式充分利用了闭包的特性。全局只需要创建一次实例,之后再创建的实例都是调用原来的这个实例。\n',1073,0,'2020-07-08',0),(876,'简单工厂模式','一、概念\n指使用一个统一的构造函数,根据传入参数的不同返回不同的类实例\n\n二、示例\nfunction Test (type) {\n  if (type === \'A\') {\n    return new function A () {\n      console.log(`I\'m a`)\n    }\n  }\n  else if (type === \'B\') {\n    return new function B () {\n      console.log(`I\'m b`)\n    }\n  }\n  else {\n    return null\n  }\n}\n\nvar t = new Test(\'A\')\n',1073,0,NULL,0),(877,'工厂模式','一、概念\n指以方法的形式包装子类,根据传入参数的不同返回对应子类的实例。\n该模式的好处在于:用户可以随时进行子类的拓展,只需要对原型添加新的方法。\n\n二、实例\nvar Court = function (type, content) {\n  // 当以new的方式调用方法时,this指向的是创建的新实例\n  // 直接调用方法时,this指向Window\n  // 这里将直接调用方法的情况进行了特殊处理,使其和new一样\n  if (this instanceof Court) {\n    return new this[type](content)\n  } else {\n    return new Court(type, content)\n  }\n}\nCourt.prototype = {\n  basketball: function (content) {\n    this.content = content\n      ; (function (content) {\n        console.log(content + \'basketball\')\n      })(content)\n  },\n  football: function (content) {\n    this.content = content\n      ; (function (content) {\n        console.log(content + \'football\')\n      })(content)\n  }\n}\n\nCourt(\'basketball\', \'5人打\')\nnew Court(\'football\', \'十人踢\')',1073,0,NULL,0),(878,'抽象工厂模式','一、概念\n抽象工厂模式与普通工厂模式不同的地方在于:\n普通工厂模式是预设了很多子类,然后有一个父类来统一管理,根据传递进来的参数决定创建哪一个子类实例;\n而抽象工厂模式是预设了很多抽象类,这些抽象类包含了普通类之间公用的属性和抽象方法。\n可以创建一个普通的类,使其通过抽象工厂提供的函数获得抽象类的属性和方法。\n\n二、示例\n// 核心方法\nfunction agency (subType, superType) {\n  if (typeof agency[superType] === \'function\') {\n    // 改变subType函数的构造函数指向\n    subType.constructor = subType\n    // 添加抽象类的所有属性到普通类的原型上\n    Object.assign(subType.prototype, new agency[superType])\n  } else {\n    throw new Error(\'抽象类不存在!\')\n  }\n}\n\n// 鼠标抽象类,定义所有鼠标公有的属性和需要实现的抽象方法\nagency.mouseShop = function () {\n  this.type = \'鼠标\'\n}\nagency.mouseShop.prototype = {\n  getName: function () {\n    return new Error(\'抽象方法不能调用\')\n  }\n}\n\n// 普通鼠标子类\nfunction mouse (name) {\n  this.name = name\n}\n// 抽象工厂实现鼠标类的继承\nagency(mouse, \'mouseShop\')\n// 实现抽象方法\nmouse.prototype.getName = function () {\n  return this.name\n}\n\nvar m = new mouse(\'雷蛇鼠标\')\nconsole.log(m.getName()) // 类私有方法\nconsole.log(m.type) // 类公有属性\n',1073,0,NULL,0),(879,'detail','详情',48,1,NULL,0),(917,'字符串与数字的运算','字符串与数字进行运算时,如1+\'2\',因为检测到运算符一边有数字,会将另一侧的字符串转换为数字进行计算,因此:\n1+\'2\' = 3\n\'2\'+1 = 3\n1+\'   2   \'=3\n1+\'a2\'=NaN',1016,2,'2020-07-01',0),(918,'对象的get,set存取器','1.概述\nes5特性,对象可以给一个属性定义get,set存取器\n\n2.例子\nvar obj = {\n  test: 1,\n  set prop (newval) {\n    if (newval > 5) return\n    else this.test = newval\n  },\n  get prop () {\n    return this.test\n  }\n}\nobj.prop = 4\nconsole.log(obj.prop)//=>4\nobj.prop = 6\nconsole.log(obj.prop)//=>4',1016,2,'2020-07-01',0),(919,'对象属性的特性','对象的属性包含一些标识他们可写,可枚举和可配置的特性。\n—数据属性的4个特性\n1.value 值\n2.writable 可写性\n--设置为false时则无法对该属性的值做任何修改\n3.enumerable 可枚举性\n--设置为false时,for..of..循环无法遍历该属性。\n4.configurable 可配置性\n--设置为false,则无法再对该属性特性进行修改。\n\n—存取器的4个特性\n1.get 读取\n2.set 写入\n3.enumerable 可枚举性\n4.configurable 可配置性\n\n对象属性的特性对象可以通过Object.getOwnPropertyDescriptor(obj,propname)方法获取。',1016,2,'2020-07-01',0),(920,'对象的可拓展性','一、概述\nes5提供了几个方法来设置对象是否可以添加新的属性,内部属性是否可以配置或删除和被修改。\n\n二、具体方法\n1.锁定(extensible)\n设置对象无法添加新的属性\n检测一个对象是否被锁定:Object.esExtensible()\n使对象被锁定:Object.preventExtensions()\n需要注意是,一但对象被锁定,就无法再变回未锁定的状态了。\n\n2.封闭(sealed)\n设置对象无法添加新的属性,且无法对已有属性进行配置或删除\n检测一个对象是否被封闭:Object.isSealed()\n使对象被封闭:Object.seal()\n\n3.冻结(frozen)\n设置对象无法添加新的属性,且无法对已有属性进行配置,删除或修改\n检测一个对象是否被冻结:Object.isFrozen()\n使对象被冻结:Object.freeze()\n',1016,2,'2020-07-01',0),(921,'关于数组length属性的可写性','每个数组都可以通过length属性获取到其长度,在js中,程序将始终保持length属性大于数组内部最大索引值,因此。\n1.将length设置为比当前数组索引大的值时:\n数组将会在尾部创建一个空的区域\n\n2.设置一个大于当前数组最大索引的数组索引时:\n数组长度会变为新的最大索引+1\n\n3*.将length设置为比当前数组索引小的值时:\n比length大的数组索引值将被删除。',1016,2,'2020-07-01',0),(923,'了解CSS的像素','https://www.zhihu.com/question/313971223',33,0,'2020-07-01',0),(924,'min','规定元素的最小值,一般与number/range表单元素配合使用。',1026,0,'2020-07-01',0),(925,'max','规定元素的最大值,一般与number/range表单元素配合使用。',1026,0,'2020-07-01',0),(926,'minlength','规定元素的最小字符长度。\n\n(这个属性其实h5之前就有,但是maxlength是h5出的,所以写在一起)',1026,0,'2020-07-01',0),(927,'maxlength','规定元素的最大字符长度。',1026,0,'2020-07-01',0),(928,'sign','符号',48,0,'2020-07-02',0),(929,'exact','精确',48,0,'2020-07-02',0),(930,'Number.isNaN()','判断值是否为NaN。\n\n语法:Number.isNaN(value)\nvalue:要判断的值\n\n注意:不能使用==或===来判断一个值是否NaN,因为NaN不等于任何值,包括它自身。',44,0,'2020-07-06',0),(982,'函数柯里化','一、概念\n函数柯里化指从一个多参的函数返回一个更少的参数的函数。\n\n二、示例\nfunction getUrl(protocol,domain,path){\n  return protocol + \'://\' + domain + \'/\' + path\n}\ngetUrl(\'http\',\'www.163.com\',\'index.html\')\n//=> http://www.163.com/index.html\n假设有这样一个库api,它的作用是拼接地址。\n此时你希望在当前页面,前两个参数都固定为\'http\'和\'www.163.com\'。但不想直接到库中修改这个api,因为这个api以后也会在其他场合用到,这时便可以使用函数柯里化。\n\nvar getUrl_temp = getUrl.bind(null, \'http\', \'www.163.com\')\ngetUrl_temp(\'happy.html\')\n//=> http://www.163.com/happy.html\n此时通过bind函数,返回一个新的函数,该函数前两个参数的固定的,只有第三个参数需要手动输入,这就是一个函数柯里化的实例。\n',1016,2,'2020-07-11',0),(983,'carousel','轮播',48,0,'2020-07-03',0),(984,'keyframes','关键帧',48,0,'2020-07-03',0),(985,'slide','滑动',48,0,'2020-07-03',0),(986,'惰性加载函数','一、概述\n惰性加载函数指只在函数第一次被执行时进行完整逻辑判断，之后再次使用函数会直接返回第一次执行的结果。\n若在合适的场景下使用惰性加载函数，无疑是非常节省内存的。\n\n二、应用场景\n如判断用户的平台是电脑端或手机端时,只在用户进入网页时进行一次判断，之后直接返回判断的结果。\n就算用户在期间通过某些奇奇怪怪的途径改变了它的平台(如浏览器的模拟手机浏览功能),也依然会按照第一次判断的结果返回。\n\n三、惰性加载函数的两种方法\n1.通过函数重写\nfunction isPC() {\n    var userAgentInfo = navigator.userAgent;\n    var Agents = [\"Android\", \"iPhone\",\n        \"SymbianOS\", \"Windows Phone\",\n        \"iPad\", \"iPod\"];\n    for (var v = 0; v < Agents.length; v++){\n      if (userAgentInfo.indexOf(Agents[v])>0)\n      {\n         isPC = function () {\n         console.log(\'只有电脑端才能访问。\');\n       }\n       return isPC();\n    }\n  }\n  isPC = function () {\n    console.log(\'Hello,world!\');\n  }\n  isPC();\n}\nisPC();\nconsole.log(isPC);\n//=>console.log(\'Hello,world!\');\n\n2.通过闭包\nlet isPC = (function () {\n    var userAgentInfo = navigator.userAgent;\n    var Agents = [\"Android\", \"iPhone\",\n        \"SymbianOS\", \"Windows Phone\",\n        \"iPad\", \"iPod\"];\n    for (var v = 0; v < Agents.length; v++) {\n      if(userAgentInfo.indexOf(Agents[v])>0)\n      {\n            return function () {\n               console.log(\'只有电脑端才能访问。\');\n            };\n       }\n    }\n    return function () {\n        console.log(\'Hello,world!\');\n    }\n})();\n',1016,2,'2020-07-04',0),(987,'setTimeout()','设置一段时间后执行回调异步函数。\n\n语法:setTimeout(func,delay,...paras)\nfunc:要执行的回调函数\ndelay:延时时长,单位为毫秒\nparas:可选,传递给回调函数的参数\n\n示例:setTimerout(function(){\n   console.log(111)\n},1000)\n// 以上代码使控制台在1秒后输出111',56,5,'2020-07-10',0),(988,'clearTimeout()','清除一个已定义的单次定时器。\n语法:clearTimeout(timer)\ntimer:使用setTimeout方法创建的计时器对象。\n\n补充:若希望使用该方法清除计时器,需要在定义计时器时间计时器赋值给一个变量。\nvar a=setTimeout(function(){\n   console.log(111)\n},1000)\nclearTimeout(a)',56,4,'2020-07-04',0),(989,'防抖和节流','一、概述\n防抖和节流都是为了解决用户在短时间内频繁触发事件造成卡顿而出现的解决方案。\n\n二、示例\n现在有一个showTop()方法,用户每次滑动滚动条都会触发它。\n\nfunction showTop() {\n    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    console.log(\'滚动条位置：\' + scrollTop);\n}\nwindow.onscroll = showTop;\n//=>监听到浏览器滚动时触发事件\n\n此时会注意到,用户每次滑动滚动条，甚至只是轻轻的滑了一下，都会触发这个事件近十次。\n若滑动的比较远，甚至会触发上百次，这无疑是浪费性能的。\n因此我们需要对这段代码进行改进。\n(以下其他示例基于showTop方法)\n\n1.防抖\nfunction debounce(fn, delay) {\n    let timer = null;\n    return function () {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(fn, delay);\n    }\n}\nwindow.onscroll = debounce(showTop, 200);\n\n防抖的目的是:用户在短时间内频繁触发事件时,只响应最后触发的那一次事件。\n它运用了闭包,将事件延时200毫秒执行，在此期间再次触发事件时，将计时器清空并重新开始计时。\n\n2.节流\n\n\n节流的目的是:无论用户触发事件有多么频繁,按照一个指定间隔触发一次函数,直到用户停止触发。\nfunction throttle(fn, delay) {\n    let timer = null;\n    return function () {\n        if (timer) { return false; }\n        timer = setTimeout(function () {\n            fn();\n            timer = null;\n        }, delay);\n    }\n}\nwindow.onscroll = throttle(showTop, 1000);\n\n节流同样是运用了闭包,使用一个计时器来记录希望触发事件的最小间隔并开始计时，只要计时器还在计时，用户就不会触发该事件，直到计时器停止计时并将自身置空。\n',1016,2,'2020-07-04',0),(990,'debounce','防抖',48,0,'2020-07-04',0),(991,'throttle','节流',48,0,'2020-07-04',0),(992,'toggle','切换',48,0,'2020-07-04',0),(993,'&nbsp;','空白字符。\n\n显示为\' \'',1081,0,'2020-07-04',0),(994,'&trade;','商标。\n\n显示为上标\'TM\'',1081,0,'2020-07-04',0),(995,'&copy;','版权。\n\n显示为一个圆圈里套着一个C字母',1081,0,'2020-07-04',0),(996,'&reg;','已注册。\n\n显示为一个圆圈套着一个R字母',1081,0,'2020-07-04',0),(997,'&quot;','双引号\n\n显示为\'\"\'',1081,0,'2020-07-04',0),(998,'&amp;','\'&\'符号',1081,0,'2020-07-04',0),(999,'&lt;','小于号。\n\n显示为\'<\'',1081,0,'2020-07-04',0),(1000,'&gt;','大于号。\n\n显示为\'>\'',1081,0,'2020-07-04',0),(1001,'mouseenter','当鼠标进入元素时触发事件。\n与mouseover不同,该事件不会进行传播,即仅在进入指定元素时触发。',1082,0,'2020-07-04',0),(1002,'mouseover','鼠标进入元素时触发该事件。\n与mouseenter不同,该事件会进行传播,即进入元素的子元素时也会触发该事件。',1082,0,'2020-07-04',0),(1003,'mouseleave','鼠标离开元素时触发。\n与mouseout不同,该事件不会进行传播,即仅在离开指定元素时触发。',1082,0,'2020-07-04',0),(1004,'mouseout','鼠标离开元素时触发该事件。\n与mouseleave不同,该事件不会进行传播,即离开元素的子元素时也会触发该事件。',1082,0,'2020-07-04',0),(1005,'轮播图原理','轮播图的原理其实是将需要轮播的图片放在一个容器元素中,并使它们向左浮动排成一列(建议使用ul和li作为容器)。\n在容器元素外套一个显示窗口元素(div即可),设置其宽度与所有图片一致,然后通过设置容器元素的left属性来达成图片移动的效果。\n从最后一张图到第一张图之间的无缝切换的原理是,在最后一张图后添加复制第一张图,使轮播图在显示到这张新添加的图时,left改为0,回到真正的第一张图,即可实现无缝切换。',52,0,'2020-07-04',0),(1006,'前言','再这样一段正则表达式中\n/abc/gm\n\n\'abc\'称为元字符\n\'gm\'称为修饰符',50,11,'2020-07-05',1),(1007,'reg.exec()','匹配字符串中所有符合正则表达式的子字符串并返回为一个伪数组对象。\n这个伪数组对象有两个额外的属性:index和input。\nindex返回匹配到子字符串的起始下标。\ninput返回本次匹配的字符串。\n\n语法:reg.exec(str)\nstr:要匹配的字符串\n\n该方法一般情况下与match方法并无二异,但在检索全局正则表达式时,与match不同。\nmatch检测全局正则表达式会直接返回一个数组,包含匹配到的字符串。\nexec每次被调用只从当前位置匹配下一个字符串并返回该字符串的完整信息(如其实下标等),你可以循环使用这个方法直到将整个字符串遍历完。\n每次遍历完成后,若希望下次继续从开头开始匹配,需要将正则表达式的lastIndex属性设为0。',44,12,'2020-07-05',0),(1010,'multiline','多行',48,0,'2020-07-05',0),(1011,'reg.lastIndex','设置或获取开始搜索下一个匹配项的字符下标。',53,0,'2020-07-05',0),(1012,'str.search()','该方法将返回字符串中第一个匹配正则表达式或指定字符串的下标。\n\n语法:str.search(reg)\nreg:要匹配的正则表达式\n',44,22,'2020-07-05',0),(1013,'environment','环境',48,0,'2020-07-05',0),(1014,'x(?=表达式)','先行断言。\n仅当x之后的字符串符合表达式时匹配x,但表达式的内容不会计入匹配结果。\n\n如:abc(?=de)\n将匹配abc,且其后跟随de的字符串,但匹配结果只返回abc',50,0,'2020-07-05',0),(1015,'(?<=表达式)y','后行断言。\n仅当y之前的字符串符合表达式时匹配x,但表达式的内容不会计入匹配结果。\n\n如:(?<=abc)de\n将匹配de,且其前跟随abc的字符串,但匹配结果只返回de',50,0,'2020-07-05',0),(1016,'x(?!表达式)','正向否定查找。\n仅当x之后的字符串不符合表达式时匹配x,但表达式的内容不会计入匹配结果。\n\n如:abc(!=de)\n将匹配abc,且其后不跟随de的字符串,匹配结果返回abc',50,0,'2020-07-05',0),(1017,'(?<!表达式)y','反向否定查找。\n仅当y之前的字符串不符合表达式时匹配y,但表达式的内容不会计入匹配结果。\n\n如:(?<!abc)de\n将匹配de,且其前不跟随abc的字符串,匹配结果返回de',50,0,'2020-07-05',0),(1018,'\\r','匹配一个回车符。',50,3,'2020-07-05',0),(1019,'\\n','匹配一个换行符。',50,5,'2020-07-05',0),(1020,'\\数字','返回当前正则捕获的第n个字符串。\n数字从1开始。\n\n如/(ab)c\\1/匹配\'abcab\'',50,2,'2020-07-05',0),(1021,'\\0','匹配Null字符。',50,0,'2020-07-05',0),(1022,'var和let/const的取舍','let和const都是在es6中新增的声明方式,它们引入了\"块级作用域\"的概念。\n如,在if语句中使用let或const声明的变量外部是访问不到的,这是它们关于作用域的特殊性。\n\n还有一点是,es6之前,通过var和function声明的变量,都会被认作是顶层对象的属性。\n比如在浏览器中,window是顶层对象,用var或function声明变量就等同于是给window对象添加属性,这样的设计带来了许多的问题。\n比如编译器无法在编译时就报出变量没有声明的错误,只有在具体环境下运行才会报错,因为对象的属性是动态的,程序在编译时无法确定这个属性是不是存在。\n其次,程序员在声明变量时很可能就打错声明了一个全局变量,导致变量名冲突。\n最后,顶层对象的属性是可以读写的,这并不利于模块化编程。\n\n为了解决这个问题,es6规定let,const,class声明的变量不属于顶层变量,同时为了保证兼容性,保留var,function声明变量仍是顶层变量的特性。\n\n以上便是不使用var而改用let和const的原因,如果需要定义全局变量,应该以window对象的方式声明。\n',1016,2,'2020-07-18',0),(1023,'垫片库是什么','简单来说,垫片库就是能在低级环境中使用高级环境的语法的js库。\n\n比如有es5的forEach()方法,在es3中不可用,这时你可以自己包装一个forEach类,在原生的forEach用不了时就会去调自己写的,这时这个自己写的forEach就是一个垫片,而很多垫片组成的库就叫垫片库。',1016,0,'2020-07-05',0),(1024,'如何获取运行环境的顶层对象','顶层对象指的是代码运行时的宿主对象,如浏览器运行环境下,js的顶层对象就是window或self;WebWorker运行环境下,顶层对象是self;而node运行环境下,顶层对象就是global。\n\n如何获取运行环境的顶层对象本身也是一个问题,虽然实际开发过程中一般都是能确切知道运行环境的,但是有没有一种方法能变相获取当前运行环境呢?\n\n当然可以用一个很蠢的方法来实现:\nvar getGlobal = function () {\n  if (typeof self !== \'undefined\') { return self; }\n  if (typeof window !== \'undefined\') { return window; }\n  if (typeof global !== \'undefined\') { return global; }\n  throw new Error(\'unable to locate global object\');\n};\n这段代码依次判断每个宿主对象是否存在并返回相应对象,虽然使用排除法很蠢,但也无可奈何。\n\n现在有一个提案,在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。\n垫片库system.global模拟了这个提案，可以在所有环境拿到global。\n// CommonJS的写法\nrequire(\'system.global/shim\')();\n// ES6模块的写法\nimport shim from \'system.global/shim\'; shim();\n上面代码可以保证各种环境里面，global对象都是存在的。',1016,0,'2020-07-05',0),(1027,'解构赋值','一、数组的解构赋值\nes6允许以如下的方式为变量赋值\nvar [a,b,c]=[10,11,12]\n(等价于)\nvar a=10;var b=11;var c=12\n\n接收值的参数可以一个数组的形式接收,数组中的每个参数都会对应的获取传入值对象的每个参数。\n\n传入值并不一定以一个数组的形式传入,只需要是一个具有迭代器的对象即可,将持续对该对象进行迭代自带所有接收值的参数都接收到一个值。\n\n二、默认值\n解构赋值允许两边的对象长度不相等,未指定传入值的参数为undefined。\nvar [a,b,c]=[1,2]\n//=> a=1,b=2,c=undefined\nvar [a,b]=[1,2,3]\n//=> a=1,b=2\n\n也可以为接收值传入一个默认值,如果该值没有对应的传入值,它会被设置为默认值\nvar [a,b,c=5]=[1,2]\n//=> a=1,b=2,c=5\nvar [a,b,c=5]=[1,2,3]\n//=> a=1,b=2,c=3\n\n如果默认值是一个表达式,那么这个表达式是惰性求值的,即只有用到的时候才会求值\nvar [a=f()]=[1]\n//=> a=1,f()函数不会执行\n\n默认值也可以引用其他接收值的值,前提是他已经接收到值了\nvar [a,b=a]=[1]\n//=> a=1,b=1\nvar [a=b,b=1]\n//=> 报错\n\n三、对象的解构赋值\n解构赋值不仅可以用于数组,也可以用于对象\nvar {foo,bar}={foo:1,bar:2}\n(等价于)\nvar foo=1;var bar=2\n\n但由于对象的特性,变量名只能写成对象对应的键值名,如果希望使用其他名字作为变量名,可以写成这样:\nvar {foo:zoo}={foo:1}\n//=> zoo=1\n\n四、嵌套赋值\nvar [a,{foo:b}]=[1,{foo:2}]\n//=>a=1,b=2\n只要左右两侧表达式结构一样,就可以给对应位置的变量赋值。\n\n五、应用场景\n1.交换变量的值\nvar a=1,b=2;\n[a,b]=[b,a]\nconsole.log(a,b)\n//=> a=2,b=1\n\n2.函数返回多个值\nfunction demo(){\n  return [1,2,3]\n}\nvar [a,b,c]=demo()\nconsole.log(a,b,c)\n//=>a=1,b=2,c=3\n\n3.函数无序传参\nfunction demo({a,b,c}){\n  console.log(a,b,c)\n  //=>a=1,b=2,c=3\n}\ndemo({c:3,a:1,b:2})\n\n4.提取json数据\nvar jsonData={\n  id: 42,\n  name: \'test\'\n}\nvar {id,name}=jsonData\nconsole.log(id,name)\n//=> id=42,name=\'test\'\n\n5.函数参数的默认值\nfunction demo({id:null,data:null}){\n  console.log(id,data)\n  //=> id=1,data=null\n}\ndemo({id:1})\n\n6.遍历Map数据结构对象\nvar map=new Map()\nmap.set(\'id\',0)\nmap.set(\'name\',\'快乐\')\nfor(let [key,name] of map){\n  console.log(key,name)\n  //=> key=\'id\',name=0\n  //=> key=\'name\',name=\'快乐\'\n}\n\n7.获取模块对象的指定方法\nrequire {a,b} from \'...\'\n//=> 获取模块的a,b方法\n\n六、踩坑\n使用解构赋值的上一行一定要加上分号。\n\n',1084,0,'2020-07-23',0),(1029,'普通函数与箭头函数的区别','1.语法格式\n普通:function(){表达式}\n箭头:(参数)=>{表达式}\n\n2.可否被new创建以及是否拥有原型\n普通:有\n箭头:无\n\n3.arguments对象\n普通:有\n箭头:无\n\n4.*this指向(箭头函数的主要设计目的)\n普通:函数调用者\n箭头:上一级作用域的this指向\n\n5.call,apply和bind\n普通:有,能改变this指向\n箭头:有但无效\n',1084,0,'2020-07-05',0),(1030,'表示超过0xffff的字符','es6之前,超过0xffff的字符只能用两个字节来表示,如\"\\u20BB7\"只能表示为\"\\uD842\\uDFB7\"\nes6解决了这个问题,现在只需要给十六进制符套上大括号就能表示超过0xffff的字符\n\"\\u{20BB7}\"',1084,0,'2020-07-05',0),(1032,'val.toString()','不同的数据类型对该方法进行了不同的重写。\n对于大多数数据类型,toString()方法将把他们转换为字符串。\n对于大多数引用数据类型,toString()方法返回它的具体对象类型,如\nobject.toString()=\"Object object\";\narray.toString()=\"Object array\";\n\n该方法可以传入一个参数,仅在对非引用数据类型使用时有效。\ntoString(num)\nnum:可选值有2,8,10,16,分别将调用值转换为对应进制并返回\n',44,7,'2020-07-05',0),(1033,'字符串的遍历器接口','es6中为字符串添加了遍历器接口,使其能使用for..of..等方法\nvar str=\'abc\'\nvar a=0\nfor(let c of str){\n  a++\n}\nconsole.log(a)//=>3\n\n这个方法最大的好处在于可以识别大于0xffff的码点,而传统的使用for(;;)遍历字符串长度则会认为大于0xffff的码点是两个字符导致额外遍历一次。\n',1084,0,'2020-07-05',0),(1034,'str.codePointAt()','es6方法。\n返回字符串中指定位置字符的码点。\n该方法不同于charCodeAt(),能正确识别四个字节以上的字符。\n\n语法:str.codePointAt(index)\nindex:字符下标',44,21,'2020-07-05',0),(1035,'str.includes()','es6方法。\n检测字符串中是否含有指定子字符串,返回布尔值。\n\n语法:str.includes(sonstr)\nsonstr:子字符串',44,20,'2020-07-05',0),(1036,'str.repeat()','es6方法。\n将一个字符串重复n次并返回。\n\n语法:str.repeat(times)\ntimes:重复的次数',44,19,'2020-07-05',0),(1037,'反引号','ES6除了\"\",\'\'还可以用``反引号来定义字符串。\n``中可以用${表达式}来使用变量或方法的值。\n此外,反引号中的换行和空格会被完全保留,因此以下写法是完全可行的:\nvar str=`aaaaaa\n  aaaaaaaaa`',1084,0,'2020-07-05',0),(1038,'反引号-标签模板','标签模板是反引号的一种特殊使用方法,如下:\nfn`abc`\n等价于\nfn(\'abc\')\n然而,在反引号内带有表达式时,情况就稍显复杂:\nlet test=b\nfn`a${test}b`\n等价于\nfn([\'a\',\'b\'],test)\n原字符串会以使用表达式为间隔分割为数组,而表达式的结果将作为其后的参数传入。\n',1084,0,'2020-07-05',0),(1039,'(修饰符)u','es6新增。\n\n在es5之前,无法正常识别0xffff以上的字符,会被认为是两个字符从而导致识别失败。\nes6新增了该修饰符以解决该问题,只要加上u修饰符,所有大于0xffff的字符都会被正确识别。',50,9,'2020-07-06',0),(1040,'(修饰符)y','es6新增\n\n修饰符y类似于g,都是进行全局匹配,每次都从上次成功匹配的位置开始匹配。\n但不同的是,修饰符y会确保下次匹配的内容是从上次成功匹配的位置开始,如:\nvar s=\'sss_ss\'\nvar r1=/s+/g\nvar r2=/s+/y\nr1.exec(\'s\')//=> sss\nr2.exec(\'s\')//=> sss\nr1.exec(\'s\')//=> ss\nr2.exec(\'s\')//=> null\n可以发现,r2除了第一次的每次匹配都会相当于在开头多了个^符,这也被称为粘连匹配。\n',50,8,'2020-07-06',0),(1041,'reg.flags','返回正则表达式的修饰符\n\n如:/abc/gy.flags //=> \'gy\'',53,0,'2020-07-06',0),(1042,'二进制和八进制表示法','es6提供了二进制和八进制数值的新写法。\n二进制值可以用前缀0b(0B)表示\n八进制值可以用前缀0o(0O)表示\n',1084,0,'2020-07-06',0),(1043,'Number.isFinite()','检查数值是不是有限的。\n对于非number类型的值,会先尝试将其转换为数字,对于无法转换为数字的值,会被转换为NaN。\n对于NaN值,返回false。\n\n语法:Number.isFinite(value)\nvalue:要判断的值\n',44,0,'2020-07-06',0),(1044,'Number.isInteger()','判断传入值是否为整数,返回布尔值。\n对于小数位为0的浮点数,也认为是整数,如Number.isInteger(1.0)=true\n\n语法:Number.isInteger(val)\nval:要判断的值',44,0,'2020-07-06',0),(1045,'Number.isSaveInteger()','es6新增。\n判断一个整数是否在JavaScript能准确表达的整数范围内,返回布尔值。\nJs能准确表示的数在-2^53到2^53之间,可以通过这个函数判断一个数是否处于这个区间。\n\n语法:Number.isSaveInteger(val)\nval:要判断的值\n\n需要注意的是,使用这个函数时,如果要比较的数是通过运算得到的,最好对每个运算的数都调用一次该函数。这是因为运算的数超出js能表达的最大范围时,它在计算时就会有误差,导致返回的数反而处于js能表达的最大范围临界点处。\n',44,0,'2020-07-06',0),(1046,'integer','整数',48,0,'2020-07-06',0),(1047,'新的运算符**','es6引入了新的运算符**,它可以计算左边的数的右边数次方。\n如:2**3 //=> 8\n\n相对应的也引入了新的赋值运算符**=\n如:\nvar a=2\na**=3\nconsole.log(a)//=> 8',1084,0,'2020-07-06',0),(1048,'Array.from()','es6新增。\n用于将类数组对象和可遍历的对象转化为数组。\n判断对象是不是类数组对象,最直观的是看它有没有length属性。\n\n语法:Array.from(obj,fn)\nobj:要转换的对象\nfn:可选。为对象迭代的每个属性执行的函数\n\n对于还没有部署该方法的浏览器,可以使用以下方法替代:\n[].slice.call(obj)',44,5,'2020-07-06',0),(1049,'arr.copyWithin()','es6新增。\n该方法用于复制数组的一部分到另一个位置,然后返回当前数组,影响原数组。\n\n语法:arr.copyWithin(target,start,end)\ntarget:复制到的数组起始下标\nstart:可选,默认为0。开始复制的数组下标,允许负值。\nend:可选,默认为数组长度。结束复制的数组下标,允许负值。\n',44,44,'2020-07-06',0),(1050,'arr.find()','es6新增。\n该方法用于找出数组中第一个符合指定规则的元素,它需要传入一个方法,依次对数组所有元素调用这个方法,直到传入方法返回true则返回对应的元素。\n\n语法:arr.find(fn(n){\n  return true/false\n})\nn:正在遍历的元素',44,43,'2020-07-06',0),(1051,'arr.findIndex()','es6新增。\n该方法用于找出数组中第一个符合指定规则的元素,它需要传入一个方法,依次对数组所有元素调用这个方法,直到传入方法返回true则返回对应的元素下标。\n\n语法:arr.findIndex(fn(n){\n  return true/false\n})\nn:正在遍历的元素',44,42,'2020-07-06',0),(1052,'arr.fill()','es6新增。\n该方法用于向数组中某一段填充一个值。\n\n语法:arr.fill(val,start,end)\nval:要填充的值\nstart:可选,默认为0。开始填充的数组下标。\nend:可选,默认为数组的长度。结束填充的数组下标的下一位。\n\n补充:注意第三个参数,并不是在指定下标结束填充,而是在指定下标的前一位结束填充。',44,41,'2020-07-06',0),(1053,'obj[iterator].keys()','es6新增。\n该方法只能由带有迭代器的对象调用,将返回一个迭代器对象,可以进行遍历获取对象每个属性的键名。\n\n示例:\nfor(let index of [1,2,3].keys()){\n  console.log(index)\n  //=>三次遍历分别返回1,2,3\n}\n\n如果不使用for..of..遍历,也可以手动调用遍历器对象的next()方法,实现对对象键名的遍历。\nvar iter=[1,2,3].keys()\nconsole.log(iter.next().value)\n',44,71,'2020-07-07',0),(1054,'obj[iterator].values()','es6新增。\n该方法只能由带有迭代器的对象调用,将返回一个迭代器对象,可以进行遍历获取对象每个属性的键值。\n\n示例:\nfor(let val of [3,2,1].values()){\n  console.log(val)\n  //=>三次遍历分别返回3,2,1\n}\n\n如果不使用for..of..遍历,也可以手动调用遍历器对象的next()方法,实现对对象键值的遍历。\nvar iter=[1,2,3].values()\nconsole.log(iter.next().value)\n',44,70,'2020-07-07',0),(1055,'obj[iterator].entries()','es6新增。\n该方法只能由带有迭代器的对象调用,将返回一个迭代器对象,可以进行遍历获取对象每个属性的键值和键名。\n该迭代器每次会返回一个数组对象,需要对该数组进行解构赋值以正确遍历到数组的键名和键值。\n\n示例:\nfor(let [key,value] of [3,2,1].values()){\n  console.log(key)\n  //=> 三次遍历分别返回1,2,3\n  console.log(value)\n  //=> 三次遍历分别返回3,2,1\n}\n\n如果不使用for..of..遍历,也可以手动调用遍历器对象的next()方法,实现对对象键值和键名的遍历。\nvar iter=[\'a\',\'b\',\'c\'].values()\nconsole.log(iter.next().value)\n//=> [0,\'a\'],[1,\'b\'],[2,\'c\']\n\n',44,69,'2020-07-06',0),(1056,'arr.includes()','es7方法。\n判断数组是否包含指定值,返回布尔值。\n\n语法:arr.includes(val,start)\nval:要判断是否被包含的值\nstart:可选,默认为0。指示开始搜索的数组下标\n\n示例:\n[1,2,3].includes(1)//=> true\n[1,2,3].includes(4)//=> false\n',44,40,'2020-07-06',0),(1057,'参数默认值','es6允许用户直接给函数的参数设置默认值。\nfunction(a,b=2){/* ... */}\n\n比较有意思的是,参数的默认值是惰性求值的,也就是它每次被调用都会重新计算。\nvar x=100\nfunction demo(a=x){ console.log(a) }\nconsole.log(demo())//=> 100\nx=200\nconsole.log(demo())//=> 200\n\n如果参数的默认值计算表达式中可以引用其他在其之前的参数,如:\nfunction demo(a,b=a){\n  console.log(b) //=> 3\n}\ndemo(3)\n\n利用函数默认值,可以指定某个参数必须被传入,否则抛出错误,如:\nfunction demo(a=nullValue()){\n  console.log(1)\n}\nfunction nullValue(){\n  throw new Error(\'参数未被传入\')\n}\ndemo(1) //=> 1\ndemo() //=> 报错',1084,0,'2020-07-06',0),(1058,'暂时性死区','在let命令声明变量的语句前,该变量都是不可被调用的,这在语法上被称为暂时性死区。',1084,0,'2020-07-06',0),(1059,'rest','其余',48,0,'2020-07-06',0),(1060,'rest参数','es6引入了rest参数的概念,即可以获取任意个多余参数并放入一个数组,这样就再也不需要用到arguments了\n\n示例:\nfunction demo(a,...rest){\n  console.log(rest)\n  //=> [2,3,4,5]\n}\ndemo(1,2,3,4,5)\n\n注意,rest参数后不能再有其他的参数,否则会报错。',1084,0,'2020-07-06',0),(1061,'扩展运算符','一、概述\n扩展运算符类似于rest参数的逆运算,它用于将带有iterator遍历器的对象转化为用逗号分隔的参数序列。\n\n二、示例\nfunction demo(a,b,c){\n  console.log(a,b,c)\n  //=> 1,2,3\n}\ndemo(...[1,2,3])\n\n三、应用场景\n1.合并数组\nvar arr1=[1,2,3]\nvar arr2=[4,5,6]\nconsole.log([...arr1,...arr2])\n//=> [1,2,3,4,5,6]\n\n2.获取解构赋值的额外参数\nvar [a,...rest]=[1,2,3,4,5]\nconsole.log(a) //=> 1\nconsole.log(rest) //=>[2,3,4,5]\n\n3.获取字符串的正确长度\n字符串默认的length属性会误将超过0xffff的字符当做两个字符,可以通过扩展运算符来获取字符串的正确长度。\nvar str=\'abcdef\'\nconsole.log([...str].length) //=> 6\n\n4.将带有遍历器的对象转化为真正的数组\nvar div = document.querySelectorAll(\'div\')\ndiv = [...div]\n与Array.from()不同的是,扩展运算符无法把没有配置遍历器的类数组转化为真正的数组。\n\n\n',1084,0,'2020-07-06',0),(1062,'func.name','返回函数的函数名。\n\n示例:function demo(){\n  console.log(demo.name) //=> \'demo\'\n}\n\n如果一个匿名函数赋值给了一个变量,es5之前,这个属性会返回一个空字符串。\nes6对这点做出了修改,现在这个属性会返回赋给变量的名。\n\n如果对象方法使用了存取器(getter,setter),那么无法直接从该对象的方法上获取方法名,需要到它的存取器(getter,setter)上获取。\n\n另外有三种特殊情况:\n1.若函数是通过bind方法创建的,则该属性会返回\'bound\'+原函数名字;\n2.若函数是通过Function构造函数创建的,则会返回\'anonymous\'(匿名的意思)\n3.若函数名是Symbol类型的值,则该属性会返回Symbol值的描述。\n',53,1,'2020-07-07',0),(1063,'*函数尾调用','一、概念\n函数尾调用指在一个函数内部,执行了另一个函数且其后没有其他的操作。\n\n二、示例\n一个标准的尾调用函数:\nfunction demo(){\n  return a()\n}\n\n以下情况不属于尾调用:\n1.function demo(){\n  var y=a()\n  return y\n}\n尽管和之前的例子语义上一样,但a函数在执行后还进行了赋值的操作,因此不算尾调用。\n\n2.function demo(){\n  return a()+1\n}\na函数执行后进行了+1的操作,因此不算尾调用。\n\n3.function demo(){\n  a()\n}\na函数执行后,因为demo函数没有返回值,会隐性在其后添加return undefined,因此a()不是最后执行的语句,也不算尾调用。\n\n函数尾调用并不一定需要调用的函数在主函数的内部最后一条语句,也不一定一个主函数只有一个尾调用的函数,如:\nfunction demo(flag){\n  if(flag){\n    return a()\n  } else {\n    return b()\n  }\n}\n在这个函数体中,a和b都属于函数尾调用,因为函数执行时它们之后都不会再进行其他的操作。\n\n三、作用\n函数尾调用之所以如此特殊,主要是因为函数的\'调用帧\'。\n函数在调用时,会在内存形成一个调用记录,又称为调用帧,保存函数的调用位置和内部变量等信息。\n如果在函数A中使用了函数B,就会在A的调用帧上再生成一个B的调用帧,如果B里面还用了函数C,还会在B的调用帧上再生成一个C的调用帧,以此类推..这样,就形成了一个调用栈。\n\n而尾调用函数则没有这个问题,因此函数是在最后调用的,无需保留原函数的变量等,因此就不会再保留A的调用帧,直接生成一个尾调用的调用帧,这样就减少了内存负担。\n\n四、需要注意的事项\n尾调用优化仅在严格模式下能够使用,因为非严格模式下有arguments和callee两个属性,而尾调用会使函数的调用栈被改写,这两个属性就会失真。\n而严格模式下,这两个属性被禁用,自然也就可以正常使用使用函数尾调用了。\n若希望在正常模式下使用函数尾调用(尾递归),可以参考本目录的【尾递归优化的完美实现】。\n\n五、拓展\n在函数中调用并返回函数结果,最典型的就是递归。当然,递归也是有自己的调用栈的,如果不使用尾递归的方法,将非常大的损害内存并且可能发生栈溢出。\n因此尝试将递归函数改成尾递归的形式是非常有必要的。\n',1016,0,'2020-07-07',0),(1064,'蹦床函数','蹦床函数是使用循环代替递归的一种方法。\n\n如:\n/* 蹦床函数,第二个参数可以传入一个函数,对单次函数调用获取的值和之前获得的值进行运算并将返回结果作为下次的第二个参数 */\nfunction trampoline (f, f2) {\n  let sum = 0\n  while (f && f instanceof Function) {\n    let w\n    [w, f] = f()\n    sum = f2(w, sum)\n  }\n  return sum\n}\n// 希望递归的函数,功能是将0~a的所有数字加起来\nfunction demo (a, b = 0) {\n  if (b < a) {\n    return [b, demo.bind(null, a, ++b)]\n  } else {\n    return [b, null]\n  }\n}\n// 调用\nvar result2 = trampoline(demo.bind(null, 10), function (a, b) {\n  return a + b\n})\nconsole.log(result2) //=> 55\n',1016,0,'2020-07-06',0),(1067,'*尾递归优化的完美实现','function accumulator(fn) {\n  var value\n  var flags = false\n  var arrs = []\n  return function() {\n    arrs.push(arguments)\n    if (!flags) {\n      flags = true\n      while (arrs.length) {\n        value = fn.apply(fn, arrs.shift())\n      }\n      flags = false\n    }\n    return value\n  }\n}\nvar foo = accumulator(function (a, b) {\n  if (b > 0) {\n    return foo(a + 1, b - 1)\n  } else {\n    return a\n  }\n})\nconsole.log(foo(1, 1000000))\n//=> 1000001\n\n好吧,这段代码刷新了我的三观,看了老半天才看懂。\n来分析一下。\n首先调用foo(1,1000000),相当于传入accmulator类的返回方法中。\n然后传入的参数(arguments)被添加到闭包的数组内,这个数组就变成了[[1,1000000]]。\n接下来判断闭包变量flags,这个值没变过,是初始值false,于是进入分支,将flags改为true\n重点来了！\n这时候进入循环,只要闭包数组arrs还有值就重复执行代码块,此时这个数组时[[1,1000000]],因此开始执行。\n判断fn.apply(fn,arrs.shift()),注意,arrs.shift()会删除数组开头的元素并将其返回,也就是说:数组arrs变成了[],并且调用了fn(1,1000000)\n进入形参函数fn,此时a=1,b=1000000,经过简单的判断,返回函数foo(2,999999)。\n这就和我们开头调用函数时相同,只是传入的参数不同了,又进入了闭包函数中。\n此时执行arrs.push(),闭包数组又变成了[[2,999999]]。\n接下来,判断flags是否为假,此时注意到,flags已经在上一次闭包的时候变成了真,因此这次不会进入代码块。\n然后继续下去,value没有被赋值过,因此返回undefined。\n好,这时第一次循环的结果已经返回了,也就是value=undefined。\n此时继续判断arrs数组的长度,因为刚刚的操作,闭包数组现在是[[2,999999]],它又有值了。。\n因此进入下一次循环,这次又会把2和999999作为参数传进去,和上面一样又返回了3和999998。\n重复n次后,直到第二个参数===0,就会return a,这时的a也就是1000001,直接返回。\n因为数组这次没有插入值,循环结束,并且value第一次赋到非undefined值1000001,出循环后,value被返回。\n',1016,0,'2020-07-07',0),(1068,'generator','生成器',48,5,'2020-07-07',0),(1069,'yield','产生',48,0,'2020-07-07',0),(1070,'斐波那契数列','类似0 1 1 2 3 5 8 13 21 34...\n以0和1开始,之后每一位元素都是前两位的和,这样的数列被称为斐波那契数列。',1043,0,'2020-07-07',0),(1071,'expect','预期',48,0,'2020-07-07',0),(1072,'属性的简洁写法','es6提供了对象属性的简洁写法,如:\nvar a = 1\nvar obj={\n  a\n}\n等同于\nvar a = 1\nvar obj={\n  a:a\n}\n\n同时也提供了对象方法的简洁写法,如:\nvar obj={\n  fn(){\n    /* 方法内容 */\n  }\n}\n等同于\nvar obj={\n  fn:function(){\n    /* 方法内容 */\n  }\n}\n\n若需要简写的方法是一个Generator(生成器),则可以这么表示:\nvar obj={\n  // 注意这里的星号\n  * fn(){\n    /* 生成器内容 */\n  }\n}\n\n此外,属性的简洁写法和属性名表达式不允许同时使用。\n',1084,0,'2020-07-07',0),(1073,'属性名表达式','es5及其之前,调用对象的属性可以通过两种方式:\n// 方法1\nobj.prop\n// 方法2\nobj[prop]\n但在定义对象的属性名时只能使用第一种方法:\nvar obj={\n  prop1:1,//=> 正常\n  [prop2] //=> 报错\n}\nes6允许使用方括号法来定义对象属性,因此现在这么写不会报错了。\n此外,属性的简洁写法和属性名表达式不允许同时使用。\n',1084,0,'2020-07-07',0),(1074,'anonymous','匿名',48,0,'2020-07-07',0),(1075,'Object.is()','es6方法。\n判断两个值是否相等。行为类似于===运算符,不同的是,它会认为+0不等于-0,并且能正确判断NaN等于NaN。',44,92,'2020-07-07',0),(1076,'for..in..和Object.keys()比较','for..in..循环会遍历对象中所有可枚举的自身属性和继承属性键名,一般情况下,我们是不需要遍历对象的继承属性的。\nObject.keys()循环正好满足了这个需求,它只会遍历对象中所有可枚举的自有属性键名。\n为了不让操作困难化,应尽量避免使用for..in..遍历对象而改用Object.keys',1016,0,'2020-07-07',0),(1077,'Object.getOwnPropertySymbols()','返回一个数组,包含对象的所有Symbol类型属性键值。\n\n语法:Object.getOwnPropertySymbols(obj)',44,83,'2020-07-07',0),(1078,'Reflect.ownKeys()','该内部方法返回对象的所有自身属性,无论属性是Symbol类型或字符串,也无论属性是否不可枚举。\n\n语法:Reflect.ownKeys(target)\ntarget:目标对象',44,123,'2020-07-10',0),(1079,'对象的遍历顺序','首先,直到es6共有5种方法遍历对象的属性键值:\n(1)for..in..\n(2)Object.keys(obj)\n(3)Object.getOwnPropertyNames(obj)\n(4)Object.getOwnPropertySymbols(obj)\n(5)Reflect.ownKeys(obj)\n\n这五种方法都按照以下顺序来进行遍历:\n(1)键值为number类型的属性优先遍历,按照数字大小排序,小的排前面。\n(2)键值为string类型的属性其次遍历,按照属性被添加的时间排序,先添加的排前面。\n(3)键值为symbol类型的属性最后遍历,按照属性呗添加的时间排序,先添加的排前面。\n',1016,0,'2020-07-07',0),(1080,'不使用__proto__属性的原因','__proto__可以用来读取或设置当前对象的prototype对象,该属性几乎已经被所有浏览器所支持。\n但从它左右的两个下划线就可以看出,这是一个内部属性,因此es6并没有将它写入正文,而是写入了附录,并且明确表示除了浏览器外的任何环境不一定需要部署这个属性。\n因此无论从语义,或是兼容角度考虑,应该避免使用这个属性,而使用es6正式推荐的Object.getPrototypeOf(),Object.setPrototypeOf(),Object.create()三个方法进行取代。',1016,0,'2020-07-07',0),(1081,'Reflect.setPrototypeOf()','该内部方法用于设置一个对象的原型对象。\n\n语法:Reflect.setPrototypeOf(target,object)\ntarget:要改变原型对象的对象\nobject:设置后指向的原型对象',44,116,'2020-07-10',0),(1082,'Object.create()','创建一个指定了原型对象且带有自定义的数据属性和访问器属性的对象,通过这种方式创建的对象属性默认是不可遍历的。\n\n语法:Object.create(proto,objProps)\nproto:原型对象\nobjProps:对象,包含新创建对象的访问器属性和数据属性。\n\n示例:\nvar yuanxing={}\nvar obj=Object.create(yuanxing,{\n  // 数据属性\n  foo: { \n    writable:true,\n    configurable:true,\n    value: \"hello\" \n  },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) {\n      console.log(111)\n    }\n  }\n})',44,104,'2020-07-07',0),(1083,'CSS Peek','在html中右键单击选择器时,选择\"Go toDefinition和Peek definition\"选项,就可以跳到相应的CSS代码。',1037,0,'2020-07-07',0),(1084,'Color Info','鼠标悬停在css的定义颜色(如rgb)上时,可以浏览这个颜色的效果。',1037,0,'2020-07-07',0),(1085,'Object.keys()','es5新增。\n将返回一个数组,包含指定对象的所有可枚举的自有键名,该方法将过滤键名为Symbol值的元素。\n\n语法:Object.keys(obj)\nobj:要获取键名的对象',44,103,'2020-07-07',0),(1086,'Object.values()','返回一个数组,该数组包含指定对象所有属性的键值,该方法将过滤键名为Symbol值的属性。\n\n语法:Object.values(obj)\nobj:要获取键值的对象',44,102,'2020-07-07',0),(1087,'Object.entries()','返回一个数组,该数组包含对象所有可遍历的键名和键值,该方法将过滤键名为Symbol值的属性。\n\n语法:Object.entries(obj)\nobj:要获取键名和键值信息的对象\n\n将返回如下结构的数组:\n[[key1,value1],[key2,value2],[key3,value3]...]\n这个结构的数组也可以用来创建Map构函的实例,因此可以用这种方式将对象转化为Map对象:\nvar m=new Map(Object.entries(obj))',44,101,'2020-07-07',0),(1088,'Null传导运算符','在实际业务场景中,使用一个方法往往需要判断这个方法是否存在,如message.body.user.firstName,需要进行嵌套判断:\nconst firstName=message&&\n     message.body&&\n       message.body.user&&\n        message.body.user.firstName)||\'default\'\n\n这样显得代码十分亢长且维护起来很麻烦,因此出现了Null传导运算符,以上代码可以简写为:\nconst firstName=message?.body?.user?.firstName||\'default\'\n这段代码的执行步骤为:\n①判断message是否为null或undefined,若非继续判断,若是返回\'default\'。\n②判断message.body是否为null或undefined,若非继续判断,若是返回\'default\'\n③判断message.body.user是否为null或undefined,若非继续判断,若是返回\'default\'\n④判断message.body.user.firstName是否为null或undefined,若非返回message.body.user.firstName,若是返回\'default\'\n\n从以上分析可以看出,\'?.\'运算符会判断左侧对象是否有右侧的键名属性,若判断结果为非null或undefined,他就会返回右侧值然后继续往下执行。\n\nNull传导运算符(?.)的用法有:\n1.obj?.prop:判断对象是否有指定属性\n2.obj?.[prop]:同上,方括号表示法\n3.func?.(...args):以右侧参数执行函数并获取返回结果,判断是否为null或undefined\n4.new Func?.(...args):构造函数调用\n\n注意,Null传导运算符与&&判断还有不同的地方在,它并不以假值为依据决定判断是否成功或失败,而是只要目标返回了null和undefined,就判断失败,否则都认为成功并返回该值。\n因此可以避免flase和0,空字符串,NaN被误判。\n',1016,0,'2020-07-07',0),(1089,'原始数据类型','Null,Undefined,Number,String,Boolean,Object,\nSymbol(ES6)',1016,13,'2020-07-07',0),(1090,'Symbol()','es6方法。\n生成并返回一个Symbol类型的值。\n\n语法:Symbol(describe)\ndescribe:描述字符串。这个值一般情况下没有什么用,但在控制台显示值或者使用toString()方法时,比较容易区分,如:\n  var s=Symbol(\'aaa\')\n  console.log(s) //=> \'Symbol(aaa)\'\n  s.toString() //=> \'Symbol(aaa)\'',44,144,'2020-07-07',0),(1091,'新的基本数据类型Symbol','一、概述\nSymbol类型的值可以通过Symbol()创建,它表示唯一值,即任何一个其他值都不可能与Symbol()创建的值相等,即使是另一个通过Symbol()创建的值。\nvar s1=Symbol()\nvar s2=Symbol()\nconsole.log(s1===s2) //=> false\n\n二、描述符\nSymbol()方法可以传入一个字符串,作为这个值的描述,但请注意,除了在控制台易于区分和使用toString()方法,这个描述符没有任何用处。\nvar s=Symbol(\'aaa\')\nconsole.log(s) //=> Symbol(aaa)\ns.toString() //=> Symbol(aaa)\n\n三、Symbol作为属性键名\n作为属性键名时可以表示对象独一无二的属性,但需要注意是,Symbol作为对象的属性键名时不能通过点运算符获取\nvar s = Symbol()\nvar obj = { [s]:1 }\nconsole.log(obj.s) //=> undefined\nconsole.log(obj[s]) //=> 1\n\n四、关于遍历\nSymbol类型的属性无法被for..in..和Object.keys(),Object.getOwnPropertyNames()等常规的方法遍历到,能遍历到Symbol类型属性的方法只有Object.getOwnPropertySymbols()和Reflect.ownKeys(),这两个方法都比较极端。\n因此希望定义一个外部无法访问的属性时,可以利用这个特性以Symbol作为它的键名。\n\n\n',1084,0,'2020-07-09',0),(1092,'强耦合','如果在维护代码时,修改一处地方需要同时修改另一处地方,这就叫做耦合,如:\nfunction demo(a,b){\n  if(a===\'test\'){\n    /* ... */\n  }\n  /* ... */\n}\ndemo(\'test\',10)\n此时,若修改函数中的判断,比如改为a===\'test2\',需要修改所有调用这个函数的地方,这种情况称为耦合。\n修改以上代码为如下:\nconst test = Symbol()\nfunction demo(a,b){\n  if(a===test){\n    /* ... */\n  }\n  /* ... */\n}\ndemo(test,1)\n这样就成功消除了耦合。\n\n耦合是难以避免的,但写代码时应该尽量做到避免耦合,做到高内聚低耦合。\n',1016,0,'2020-07-11',0),(1093,'convert','变换',48,0,'2020-07-08',0),(3111,'Symbol.for()','返回一个具有指定全局字符串标识的Symbol值,若该值已存在则会读取它,若不存在则会创建。\n\n语法:Symbol.for(flagstr)\nflagstr:标识字符串\n\n示例:\nconst s1 = Symbol.for(\'aaa\')\nconst s2 = Symbol.for(\'aaa\')\nconsole.log(s1 === s2) //=> true\n\n注意:标识指的不是描述符,也就是说Symbol(\'aaa\')和Symbol.for(\'aaa\')',44,143,'2020-07-08',0),(3112,'Symbol.keyFor()','返回一个带标识的Symbol类型值的标识。\n\n语法:Symbol.keyFor(sym)\nsym:Symbol类型值\n\n示例:\nvar s=Symbol.for(\'test\')\nconsole.log(Symbol.keyFor(s)) //=> \'test\'',44,142,'2020-07-08',0),(3113,'内置Symbol值','es6定义了一些内置的Symbol值,指向语言内部使用的方法。\n\n1.Symbol.hasInstance\n对象的该属性指向了一个内部方法。当其他对象使用instanceOf运算符,判断是不是该对象的实例时,会调用这个方法并返回它的返回值。\n\n例如:\ndemo instanceOf Obj,实际上调用的是Obj[Symbol.hasInstance](demo)\n\n2.Symbol.isConcatSpreadable\n对象的该属性为一个布尔值,指示对象作为Array.prototype.concat方法的参数时,是否会将自身扁平化。\n\n例如:\n// 默认情况下该属性为true\nlet arr = [1,2]\nlet arr2 = [3,4]\narr.concat(arr2) //=> [1,2,3,4]\n// 修改为false的情况\narr2[Symbol.isConcatSpreadable] = false\narr = [1,2]\narr.concat(arr2) //=> [1,2,[3,4]]\n\n3.Symbol.species\n对象的该属性指向一个方法,该方法返回一个构造函数,当使用new方法创建当前对象的实例时,会转为创建所指向构造函数的实例。\n注意,定义该属性需要使用get读取器。\n\n例如:\nclass MyArray extends Array {\n  static get [Symbol.species]() { \n    return Array; \n  }\n}\nvar a = new MyArray(1,2,3);\nvar mapped = a.map(x => x * x);\n\n// false\nconsole.log(mapped instanceof MyArray)\n// true\nconsole.log(mapped instanceof Array)\n\n4.Symbol.match\n对象的该属性指向一个方法,当该对象作为str.match()的参数时,返回该方法的返回值作为str.match返回的结果。\n\n例如:\nlet obj={\n  [Symbol.match](){\n    return 10\n  }\n}\n\'abc\'.match(obj) //=> 10\n\n5.Symbol.replace\n对象的该属性指向一个方法,当该对象作为str.replace的参数时,传入replace方法的调用者和除自身外的所有参数并返回该方法的返回值作为str.replace的返回值。\n\n例如:\nlet obj = {}\nobj[Symbol.replace] = function(...rest){\n  console.log(...rest)\n}\n\'123\'.replace(obj,1)//=> \'123\',1\n\n6.Symbol.search\n\n7.Symbol.split\n\n8.*Symbol.iterator\n对象的该属性指向一个遍历器方法,取代对象本身的遍历器。\n\n例如:\nclass Collection {\n  *[Symbol.iterator]() {\n    let i = 0;\n    while(this[i] !== undefined) {\n      yield this[i];\n      ++i;\n    }\n  }\n}\n\nlet myCollection = new Collection();\nmyCollection[0] = 1;\nmyCollection[1] = 2;\n\nfor(let value of myCollection) {\n  console.log(value);\n}\n// 1\n// 2\n\n9.Symbol.unscopables\n对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\n\n示例:\n// 没有 unscopables 时\nclass MyClass {\n  foo() { return 1; }\n}\n\nvar foo = function () { return 2; };\n\nwith (MyClass.prototype) {\n  foo(); // 1\n}\n\n// 有 unscopables 时\nclass MyClass {\n  foo() { return 1; }\n  get [Symbol.unscopables]() {\n    return { foo: true };\n  }\n}\n\nvar foo = function () { return 2; };\n\nwith (MyClass.prototype) {\n  foo(); // 2\n}\n上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。\n',1084,0,'2020-07-08',0),(3114,'新的数据结构Set','一、概述\nes6提供了新的数据结构Set,它类似于数组,但它所有的成员都是唯一的。\nconst s = new Set()\n[2,3,3,4,5,6,6,2].forEach(x=>s.add(x))\nfor(let n of s){\n  console.log(n) //=> [2,3,4,5,6]\n}\n\nSet数据结构内部使用以判断两个元素是否相等的算法类似于Object.is(),能够正确识别NaN值是否相等。\n\n二、遍历操作\nSet的插入顺序就是遍历顺序。\n(1) set.keys()/values()/entries()\n这三个方法遍历Set时,无论遍历的是键名还是键值,都会统一返回键值,理由是Set结构的键名与键值相等。\n\n',1084,0,'2020-07-09',0),(3115,'set.add()','es6方法。\n为Set数据结构添加一个成员。\n\n语法:set.add(val)\nval:要添加的新元素',44,0,'2020-07-09',0),(3116,'set.size','返回set数据结构值的大小。',53,0,'2020-07-09',0),(3117,'set.delete()','es6方法。\n删除Set数据结构值的某个元素,返回一个布尔值,指示删除是否成功。\n\n语法:set.delete(val)\nval:要删除的目标元素值',44,0,'2020-07-09',0),(3118,'set.has()','es6方法\n判断某个值是否为指定Set数据结构值的成员,返回布尔值。\n\n语法:set.has(val)\nval:要判断的值',44,0,'2020-07-09',0),(3119,'set.clear()','清除Set数据结构值的所有成员。\n\n语法:set.clear()',44,0,'2020-07-09',0),(3121,'新的数据结构WeakSet','一、概述\nWeakSet与Set结构类似,同样是不重复值的集合,但它们有两个区别:\n1.WeakSet只允许存放对象。\n2.WeakSet中的对象都是弱引用,即垃圾回收机制不会考虑WeakSet对该对象的引用。\n此外,也因为这个特点,WeakSet的值无法被遍历,也无法被直接读取。\n这个特性的好处是,WeakSet结构对实例的引用,不会计入垃圾回收机制。所以删除实例时,不用考虑WeakSet，也不会出现内存泄漏。\n\n二、示例\nfunction Demo(a){\n  this.a = a\n}\nvar d = new Demo(11)\nvar ws = new WeakSet([d])\nconsole.log(ws)\n以上代码输出ws实例时,可以发现ws上没有挂载Demo的实例,这是因为垃圾回收机制在代码编译到第五行时,检测到实例d没有再被引用,因此自动回收了该实例所占用的内存,此时Demo的实例被销毁,自然也就不再挂载在WeakSet的实例上。\n\nfunction Demo(a){\n  this.a = a\n}\nvar d = new Demo(11)\nvar ws = new WeakSet([d])\nconsole.log(ws)\nconsole.log(d)\n这段代码只是比上一段多了一个输出d实例信息的语句,结果却完全不同,输出的ws上挂载有Demo的实例。原因是程序运行到第五行结束,发现接下来还有对该实例的引用console.log(d),因此不会立即回收,此时自然依然挂载在WeakSet的实例上。\n',1084,0,'2020-07-09',0),(3122,'新的数据结构Map','一、概述\njs中的对象(Object),本质上是键值对的集合(Hash),但是它只能使用字符串或Symbol类型值当做键名。\nvar obj={}\nobj[\'111\']=1\nobj[111]=1\nconsole.log(obj) //=>{\'111\':1}\n如以上代码,任何非Symbol类型的值作为键名时,都会隐性调用该值的toString()方法。\n为了解决这个问题,es6提供了Map数据结构,该数据结构能使用任何类型的值作为键名。\n与对象[字符串]-[值]的结构相比,Map数据结构的[值]-[值]结构显然更像一个\'键值对\'的结构。\n\n二、构造函数初始化创建\nnew Map([[key1,value1],[key2,value2]..])\n\n',1084,0,'2020-07-09',0),(3123,'weakSet.add()','es6方法。\n为WeakSet数据结构添加一个成员。\n\n语法:weakSet.add(obj)\nobj:要添加的新对象元素',44,0,'2020-07-09',0),(3124,'weakSet.delete()','es6方法。\n删除WeakSet数据结构值的某个元素,返回一个布尔值,指示删除是否成功。\n\n语法:weakSet.delete(obj)\nobj:要删除的目标对象元素',44,0,'2020-07-09',0),(3125,'weakSet.has()','es6方法\n判断某个对象是否为指定weakSet数据结构值的成员,返回布尔值。\n\n语法:weakSet.has(obj)\nobj:要判断的对象',44,0,'2020-07-09',0),(3126,'map.size','返回map数据结构值的大小。',53,0,'2020-07-09',0),(3127,'map.set()','es6方法。\n为Map数据结构添加一个键值对成员。\n\n语法:map.set(key,val)\nkey:键名\nval:键值',44,0,'2020-07-09',0),(3128,'map.get()','es6方法。\n获取Map数据结构的一个键值对成员。\n\n语法:map.get(key)\nkey:键名',44,0,'2020-07-09',0),(3129,'map.has()','es6方法。\n判断Map数据结构有没有指定键名,返回布尔值。\n\n语法:map.has(key)\nkey:要判断的键名',44,0,'2020-07-09',0),(3130,'map.delete()','es6方法。\n删除Map数据结构中的某个键值对。\n\n语法:map.delete(key)\nkey:要删除的键值对键名',44,0,'2020-07-09',0),(3131,'map.clear()','es6方法。\n删除Map数据结构中的所有键值对。\n\n语法:map.clear()',44,0,'2020-07-09',0),(3134,'新的数据结构WeakMap','一、概述\nWeakMap数据结构类似于Map,都是以键值对的形式储存,它们不同的地方在于:\n1.WeakMap只允许以对象作为键名\n2.WeakMap存储的键名是对对象的弱引用。(关于弱引用具体看【新的数据结构WeakSet】)',1084,0,'2020-07-09',0),(3135,'weakMap.set()','es6方法。\n为WeakMap数据结构添加一个键值对。\n\n语法:weakMap.set(key,val)\nkey:键名,只能使用对象作为键名\nval:键值',44,0,'2020-07-09',0),(3136,'weakMap.get()','es6方法。\n获取WeakMap数据结构的指定键值。\n\n语法:weakSet.get(key)\nkey:要获取的键值对应键名',44,0,'2020-07-09',0),(3137,'weakMap.has()','es6方法\n判断某个对象是否为指定weakMap数据结构值的键名,返回布尔值。\n\n语法:weakMap.has(key)\nkey:要判断的键名',44,0,'2020-07-09',0),(3138,'weakMap.delete()','es6方法。\n删除WeakMap数据结构中的某个键值对。\n\n语法:WeakMap.delete(key)\nkey:要删除的键值对键名',44,0,'2020-07-10',0),(3139,'reflect','反射',48,0,'2020-07-09',0),(3140,'handler','处理程序',48,0,'2020-07-09',0),(3141,'代理对象Proxy','一、概述\nProxy构造函数用于在对指定对象做出某些操作时进行代理(重写),它不会改变原对象的行为.而会返回一个新的Proxy对象。\nlet obj = {a:1,b:2}\nlet p_obj = new Proxy(obj,{\n  get(target, key, receiver){\n    return 333\n  }\n})\nconsole.log(obj.a) //=> 1\nconsole.log(p_obj.a) //=> 333\nconsole.log(p_obj.b) //=> 333\n\n二、可拦截的操作及参数的意义\n与Reflect内部方法一一对应。\n\n三、Proxy的特殊应用\n可以将Proxy对象作为其他对象的原型函数,即如果访问对象的属性没有访问到时,回到原型链上的Proxy对象去找,而这个操作会被get拦截，返回对对象不存在属性的处理。\n\n四、Proxy的this指向问题\n经过Proxy代理获得的对象,即使没有代理任何内容,依然会改变对象this的指向,如:\nconst _name = new WeakMap();\nclass Person {\n  constructor(name) {\n    _name.set(this, name);\n  }\n  get name() {\n    return _name.get(this);\n  }\n}\nconst jane = new Person(\'Jane\');\njane.name // \'Jane\'\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n使用代理后,对象内部的this指向了Proxy,此时再去读取这个属性,自然就返回了undefined。\n这个问题可以通过在Proxy内部通过bind改变函数执行者解决。\n\n\n',1084,0,'2020-07-09',0),(3142,'在前面加下划线的变量','表示内部变量,不能被外部读取。',1016,9,'2020-07-09',0),(3143,'revocable','可撤回的',48,0,'2020-07-09',0),(3144,'集合内部方法对象Reflect','一、概述\nReflect对象内部定义了一些操作对象行为的静态方法,它的设计目的是为了将Object对象的一些明显的内部方法集中起来放到一起,并且改变一些方法的行为,使其更贴近于函数化编程。\n\nReflect内部定义的方法和Proxy对象一一对应,包括对象!也就是说,只要是Reflect定义了的方法Proxy就可以进行拦截。且无论你怎么在Proxy中修改对象行为,都可以使用Reflect返回默认的行为。\n\n二、内部方法\n1. Reflect.apply(target,thisArg,args)\n2. Reflect.construct(target,args)\n3. Reflect.get(target,name,receiver)\n4. Reflect.set(target,name,value,receiver)\n5. Reflect.defineProperty(target,name,desc)\n6. Reflect.deleteProperty(target,name)\n7. Reflect.has(target,name)\n8. Reflect.ownKeys(target)\n9. Reflect.isExtensible(target)\n10. Reflect.preventExtensions(target)\n11. Reflect.getOwnPropertyDescriptor(target, name)\n12. Reflect.getPrototypeOf(target)\n13. Reflect.setPrototypeOf(target, prototype)\n方法的详细说明在【原生方法】有记录。\n\n\n\n',1084,0,'2020-07-10',0),(3145,'Reflect.get()','该内部方法用于查找并返回对象的指定属性键值。\n\n语法:Reflect.get(target,name,receiver)\ntarget:目标对象\nname:属性键名\nreceiver:若目标对象属性部署了get函数,该参数指定函数中的this指向\n\n例:\nvar myObject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n};\n\nvar myReceiverObject = {\n  foo: 4,\n  bar: 4,\n};\n\nReflect.get(myObject, \'baz\', myReceiverObject) // 8',44,133,'2020-07-10',0),(3146,'Reflect.set()','该内部方法用于设置对象属性的键值。\n\n语法:Reflect.set(target,name,value,receiver)\ntarget:目标对象\nname:要设置的属性名\nvalue:要更改的属性值\nreceiver:若目标对象属性部署了set函数,该参数指定函数中的this指向\n\n注意:Reflect.set()会被Proxy.defineProperty()拦截。',44,132,'2020-07-09',0),(3147,'Reflect.has()','该内部方法对应key in obj中的in运算符。\n\n语法:Reflect.has(target,name)\ntarget:要判断的对象\nname:要判断是否存在的属性字符串',44,131,'2020-07-10',0),(3148,'Reflect.deleteProperty()','该内部方法等同于delete obj[key]。\n\n语法:Reflect.deleteProperty(target,name)\ntarget:要删除属性的对象\nname:要删除的属性名',44,118,'2020-07-10',0),(3149,'Reflect.construct()','该内部方法等同于new Target(...args),它提供了一种不使用new创建构造函数实例的方法。\n该方法的返回值即创建的构造函数实例。\n\n语法:Reflect.construct(target, args)\ntarget:目标构造函数\nargs:参数数组',44,122,'2020-07-09',0),(3150,'Reflect.getPrototypeOf()','该内部方法用来获取一个对象的原型对象。\n\n语法:Reflect.getPrototypeOf(target)\ntarget:要读取的对象',44,117,'2020-07-10',0),(3151,'Reflect.apply()','该内部方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。\n\n语法:Reflect.apply(target, object, args)\ntarget:需要改变this指向的Function对象\nobject:要更改到的this指向\nargs:参数数组',44,130,'2020-07-10',0),(3152,'terminal','终端',48,0,'2020-07-10',0),(3153,'promise','承诺',48,0,'2020-07-10',0),(3154,'pending','待定',48,0,'2020-07-17',0),(3155,'resolved','解决;已完成',48,0,'2020-07-17',0),(3156,'rejected','被拒绝',48,0,'2020-07-17',0),(3157,'异步容器对象Promise','一、概述\nPromise是异步编程的一种解决方案,它的构造函数可以接受一个函数,在内部写入异步操作并在异步操作结束后执行回调。\n\n二、实例\nvar p = new Promise(function(resolve,reject){\n  setTimeout(resolve,1000,\'mes\')\n})\np.then(para=>{\n  console.log(para)\n})\n以上代码将在p实例被创建后的1000毫秒后将输出\'res\'的事件插入栈中。\n可以看出,Promise构造函数接收的函数有两个形参,resolve指回调成功时触发的事件,reject指回调失败时触发的事件,两个事件都需要在异步中手动调用。\n函数中定义了一个setTimeout定时器,并指定在1000ms后触发回调resolve。\n构造函数原型上的then方法指示在Proxy构造函数传入的方法内部,触发resolve事件和reject事件时的回调。\n它的第一个参数为resolve事件触发的回调,上面代码中,延时1000ms后触发了resolve函数,then就会监听到并触发相应的事件。\n\n三、then方法的reject回调参数(不推荐)\n此外,then方法还有第二个可选参数,为触发reject事件的回调,如:\nfunction loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    var image = new Image();\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new Error(\'Could not load image at \' + url));\n    };\n\n    image.src = url;\n  });\n}\nlet p = loadImageAsync(url)\np.then(function(image){\n  console.log(image+\'加载成功\')\n},function(error){\n  throw error\n})\n加载图片失败时就会触发第二个回调函数。\n一般来说,不推荐使用then的第二个回调函数,而使用catch来捕获错误。\n\n四、then的链式调用\nresolve/reject也可以将另一个Promise实例(假设为p1)作为参数,此时会将p1的状态传递给p2。\n也就是说,如果p1的状态是pending(等待回调),这个状态会同步传递给p2,并等待p1的状态变成resolve(回调成功)或reject(回调失败)。\n此时p2的then语句会变成针对p1,也就是说,当p1触发resolve时,p2.then会触发并执行第一个参数。\n\n此外,由于只是移交控制权,如p2延时2000毫秒执行回调传入p1作为参数,p1延时3000毫秒输出\'hello\',那么无论是p2.then,还是p1.then都会在3000毫秒后输出\'hello\',而不是5000毫秒。\n\n函数的then参数,将返回一个新的Promise实例,因此可以使用链式操作。\np.then(function (para){\n  console.log(para)\n  return 123\n}).then(function (demo){\n  console.log(demo) //=> 123\n})\n可以看出,then返回的Promise实例将把本次执行的返回结果传给下次then操作的第一个参数。\n如果之前的this语句返回的是一个Promise实例,则返回的实例将替代要创建的实例。\nfunction createTimeout(ms){\n  return new Promise(function(resolve,reject){\n    setTimeout(resolve,ms,\'result\')\n  })\n}\nvar p = createTimeout(1000)\np.then(function(val){\n  console.log(val)\n  return createTimeout(2000)\n}).then(function(val2){\n  console.log(val2)\n})\n以上代码将在1000毫秒之后,输出\'result\',然后再经过2000毫秒,再次输出。\n\n五、catch语句\n除了then语句,promise还有catch语句,用来捕获错误,catch(func)相当于then(null,func)。\nvar p = createTimeout(1000)\np.then(function(result){\n  console.log(result)\n}).catch(function(err){\n  throw err\n})\n以上代码将在Promise实例变为reject状态时抛出一个错误,此外,若在其执行链上之前的所有then语句发生了错误,也会将错误传入第一个参数并执行catch中的语句。\n\n六、其他方法\n1.Promise.all()\n2.Promise.race()\n3.Promise.resolve()\n4.Promise.reject()\n方法的详细说明在【原生方法】中有记录\n\n七、使用的附加方法\n以下两个方法es6并没有提供,但非常实用,可以自己实现:\n1.done()\nPromise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。\n因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\nasyncFunc()\n  .then(f1)\n  .catch(r1)\n  .then(f2)\n  .done();\n\ndone方法的具体实现:\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  this.then(onFulfilled, onRejected)\n    .catch(function (reason) {\n      // 抛出一个全局错误\n      setTimeout(() => { throw reason }, 0);\n    });\n};\n从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。\n但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。\n\n2.finally()\nfinally方法用于指定不管Promise对象最后状态如何，都会执行的操作。\n它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\nserver.listen(0)\n  .then(function () {\n    // run test\n  })\n  .finally(server.stop);\n  \nfinally方法的具体实现:\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。\n\n八、实际应用\n1.图片加载\nfunction imgload(url){\n  return new Promise((resolve,reject)=>{\n    let img = new Image()\n    img.onload = resolve.bind(null,img)\n    img.onerror = reject.bind(null,new Error(\'defeat\'))\n    img.src = url\n  })\n}\nimgload(\'xxxxx\')\n  .then(function(img){\n  document.body.appendChild(img)\n    console.log(1)\n})\n  .catch((err)=>{\n    console.log(2)\n  throw err\n})\n以上代码将在图片加载成功时将其添加至body的子节点,并在图片加载失败时抛出错误。\n\n',1084,0,'2020-07-10',0),(3158,'Promise.all()','一、概述\n该方法用于将多个Promise实例,包装成一个新的Promise实例并返回。\n\n二、语法\nPromise.all(args)\nargs:要包装整合Promise实例\n\n三、详细分析\nall()方法返回的Promise实例,会在所有子Promise实例的状态变成resolve时触发,然后会将所有子Promise实例的resolve方法返回值整合为一个数组,作为父Promise实例resolve回调的参数。\n若是子Promise实例中有任意一个实例的状态变成了reject,将把最早变更为该状态的函数reject方法返回值传入并触发父Promise实例的reject方法。\n\n// 生成一个Promise对象的数组\nvar promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON(\"/post/\" + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n\n此外,当promise.all的参数有非Promise实例时,会为它们隐形调用Promise.resolve()方法。\n',44,0,'2020-07-10',0),(3159,'fetch','取得',48,0,'2020-07-10',0),(3160,'race','赛跑',48,0,'2020-07-10',0),(3161,'Promise.race()','一、概述\n与Promise.all()一样,Promise.race()可以接收多个Promise实例并返回一个新的Promise实例,如果参数非Promise实例,则会隐性调用Promise.resolve()方法。\n\n该方法与all()不同的地方在于,它会在第一个子Promise实例变更状态时同步变更自己的状态并执行相应的状态回调,与race的英文意思\'赛跑\'十分贴切。\n\n二、语法\nPromise.race(args)\nargs:要包装整合Promise实例\n\n三、示例\nfunction createTimeout(ms,callbackPara){\n  return new Promise((resolve,reject)=>{\n    setTimeout(resolve,ms,value)\n  })\n}\nlet p = Promise.race(createTimeout(1000,1),createTimeout(2000,2))\np.then(res=>{\n  console.log(res)\n})\n以上代码将在1000毫秒后输出1\n\n',44,0,'2020-07-10',0),(3162,'Promise.resolve()','一、概述\n这个方法用来将非Promise对象实例值转化为Promise对象实例。\n\n二、语法\nPromise.resolve(val)\nval:要转化的值\n\n三、详细分析\nPromise.resolve如何转化由要转化值的类型来决定。\n1.参数是一个Promise实例\n如果参数是一个Promise实例,将原封不动将其返回。\n\n2.参数是一个thenable对象\nthenable对象指具有then方法的对象,如:\n{\n  then(resolve,reject){\n    /* ... */\n  }\n}\nPromise.resolve()方法将把这个对象转为Promise对象并初始化状态为resolved,然后立即执行then方法。\n\n3.参数不符合以上两种情况且存在\nPromise.resolve()方法将返回一个新的Promise对象,其状态初始化为resolved。\n这种情况下resolved回调函数会立即执行,并且将Promise.resolve的参数作为回调函数的参数。\n\n4.不带有任何参数\n如果不带有任何参数,基本行为与第三点情况相同,唯一的差别是resolve的回调函数没有参数。\n\n以上2,,3,4点返回的Promise对象都是初始状态都是resolved,这种情况下,回调函数会被插入本轮事件循环(event loop)的末尾而不是下一轮的开头,因此会先于其他类似于setTimeout(func,0)的异步事件执行。\n\n\n\n\n',44,0,'2020-07-10',0),(3163,'Promise.reject()','一、概述\n类似于Promise.resolve(),这个方法用来将非Promise对象实例值转化为Promise对象实例。\n不同的是,Promise.reject()方法创建的Promise实例的初始状态是rejected。\n\n二、语法\nPromise.reject(val)\nval:要转化的值\n\n三、详细分析\n与Promise.reject()不同,无论Promise.reject()传入的值是什么,该方法都会将其作为对应实例reject的回调参数。\n',44,0,'2020-07-10',0),(3164,'load','页面或图片完全加载完成时触发。\n对于window对象,将在内部图片、dom树、js文件全部加载完成时触发。\n适用标签:<window>，<body>, <frame>, <frameset>, <iframe>, <img>, <link>, <script>',1082,0,'2020-07-13',0),(3165,'error','在文档,图像或音视频加载过程中发生错误时被触发。\n\n适用标签:<img>, <object>, <style>, <video>, <audio>',1082,0,'2020-07-10',0),(3166,'async','异步',48,0,'2020-07-10',0),(3167,'遍历器Iterator','一、概念\nIterator即遍历器,一个部署了iterator接口的对象就可以被for..of..,Object.keys()等方法遍历,也可以进行解构赋值,使用扩展运算符等作用。\n数组,类数组和Set,Map数据结构原生带有自身的遍历器。\n\n二、为对象添加遍历器\n为对象指定Symbol.iterator方法属性以为其添加遍历器接口,该方法每次遍历返回一个对象。\nlet obj = {\n  data: [ \'hello\', \'world\' ],\n  [Symbol.iterator]() {\n    const self = this;\n    let index = 0;\n    return {\n      next() {\n        if (index < self.data.length) {\n          return {\n            value: self.data[index++],\n            done: false\n          };\n        } else {\n          return { value: undefined, done: true };\n        }\n      }\n    };\n  }\n};\nSymbol.iterator方法必须返回一个对象,该对象包含value属性和done属性。\nvalue属性指示单次遍历的结果。\ndone属性指示是否已经遍历完成,遍历完成时返回true。\n',1084,0,'2020-07-10',0),(3168,'生成器Generator','一、概述\n生成器的定义类似于普通的函数,它执行后返回一个遍历器对象,可以在希望的地方暂停执行函数并返回一个值。\n\n二、基本示例\nfunction* gen(){\n  for(let i = 0;i < 2;i++){\n    yield i\n  }\n  return \'over\'\n}\n以上代码定义了一个生成器函数gen,与普通函数不同,定义生成器时需要在function之后添加一个*号。\n\nlet it_gen = gen()\nit_gen.next()\n//=> {value:0, done:false}\nit_gen.next()\n//=> {value:1, done:false}\nit_gen.next()\n//=> {value:\'over\', done:true}\nit_gen.next()\n//=> {value:undefined, done:true}\n这段代码中,通过执行生成器函数gen返回了一个遍历器it_gen,之后通过使用next()方法遍历这个遍历器对象。\n\n代码会在执行到yield语句时暂停(保留当前函数状态)并返回yield其后跟着的值,下次再调用next方法就从上次暂停的地方再开始。\n直到之后只有return语句时(若没有函数尾部会默认生成return undefined语句),遍历器的遍历状态会修改为完成(true)并返回return返回值,\n\n三、Generator的惰性求值特性\nGenerator并非在生成迭代器时先将函数执行一遍获得结果对象,而是惰性求值的。\n也就是说,每次执行next语句都会将内部代码从上次保存的状态继续执行下去。\n\nlet a=0\nfunction* demo(){\n  yield a\n  yield a\n}\nvar it_demo = demo()\nconsole.log(it_demo.next()) //=> 0\na = 10\nconsole.log(it_demo.next()) //=> 10\n利用这个特性,也可以使用生成器来延时执行函数。\n\nfunction* demo(){\n  console.log(111)\n}\nlet d = demo()\nsetTimeout(function(){\n  d.next()\n},1000)\n以上代码将在1000毫秒后输出111\n\n四、表达式内使用yield语句\nfunction* demo() {\n  console.log(\'Hello\' + (yield));\n  console.log(\'Hello\' + (yield 123));\n}\nlet d=demo()\nconsole.log(d.next())\n//=> {value:undefined, done:false}\nconsole.log(d.next())\n//=> {value:123, done:false}\n在表达式中使用yield语句,必须用小括号把它包裹起来,否则会抛出一个错误。\n然后可以观察一下代码的执行顺序,第一次迭代,生成器内的console.log没有触发,而是获取了yield的返回值就停止了。\n第二次迭代,这才执行了生成器内的第一句console.log,此时由于next()没有传值,输出的是Helloundefined(关于next传值之后会说)。\n从此处可以看出,在表达式内使用yield语句时,会先在yield语句处暂停,等待下次迭代才取出yield语句获取的值,传递给当前语句。\n\n五、带参数的next()方法\n在next()方法内带的参数将在下次执行时,取代上一次yield语句的返回值。\n\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n第一次执行时,会在yield(x+1)语句处暂停,返回6。\n第二次执行时,将yield(x+1)替换为传入值12,即2*12=24,然后执行yield语句y/3,即24/3,返回8.\n第三次执行时,将yield(y/3)替换为传入值13,赋值给z,此时x = 5, y = 24, z = 13,返回5 + 24 + 13 = 42。\n\n六、yield*的应用\nyield*在生成器内使用将遍历其所跟随的迭代器对象并返回每个遍历项。\nlet read = (function* () {\n  yield* [\'h\',\'e\',\'l\',\'l\',\'o\']\n})();\n\nread.next().value // \"h\"\nread.next().value // \"e\"\nread.next().value // \"l\"\nread.next().value // \"l\"\nread.next().value // \"o\"\n\n七、返回的遍历器对象方法\ngenerator.throw(err)\n\n在【原生方法】有详细记录\n\n八、应用场景\n1.异步回调\n可以使用生成器来设置异步执行函数的回调,这样能显得代码更有逻辑性。\nfunction* gen_demo(){\n  console.log(1)\n  yield setTimeout(func, 1000)\n  console.log(3)\n}\nlet g = gen_demo()\nfunction func(){\n  console.log(2)\n  g.next()\n}\ng.next()\n以上代码等同于\nconsole.log(1)\nsetTimeout(function(){\n  console.log(2)\n  console.log(3)\n},1000)\n',1084,0,'2020-07-11',0),(3169,'step','步骤',48,0,'2020-07-11',0),(3170,'异步操作的同步化表达','es6之前的异步操作表达是这样的\nsetTimeout(() => {\n  /* 第一段代码 */\n  setTimeout(() => {\n    /* 第二段代码 */\n    setTimeout(() => {\n      /* 第三段代码 */\n    }, 3000)\n  }, 2000)\n}, 1000)\n看着就感觉凌乱的让人抓狂,回调三层还好,四层,五层或更多层的时候,就很难对代码进行添加和维护,改某一层的回调函数可能需要改上下层的其他所有回调函数,形成强耦合,这也被称为\"回调地狱\"。\n\nes6提供了Promise对象和Generator对象用来处理这个问题。\n1.使用Promise对象的写法\nfunction createPromise (ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve()\n    }, ms)\n  })\n}\nlet p = createPromise(1000)\np.then(() => {\n  /* 第一段代码 */\n  return createPromise(2000)\n}).then(() => {\n  /* 第二段代码 */\n  return createPromise(3000)\n}).then(() => {\n  /* 第三段代码 */\n}).catch((err) => {\n  throw err\n})\n这种写法就能较为轻松的找出指定的代码,看着舒爽很多。\n\n2.使用Generator对象的写法\nfunction* itGenerator () {\n  yield createTimeout(1000)\n  // 第一段代码\n  yield createTimeout(2000)\n  // 第二段代码\n  yield createTimeout(3000)\n  // 第三段代码\n  return undefined\n}\nlet it = itGenerator()\nfunction createTimeout (ms) {\n  setTimeout(() => {\n    it.next()\n  }, ms);\n}\nit.next()\n这种写法相较Promise对象更加直观,在每一段异步代码前注释声明代码段作用即可。\n',1084,0,'2020-07-11',0),(3171,'hell','地狱',48,0,'2020-07-11',0),(3172,'代码亢余','指无意义的代码重复出现占用大量空间时,如:\nvar readFile = require(\'fs-readfile-promise\');\nreadFile(fileA)\n.then(function (data) {\n  console.log(data.toString());\n})\n.then(function () {\n  return readFile(fileB);\n})\n.then(function (data) {\n  console.log(data.toString());\n})\n.catch(function (err) {\n  console.log(err);\n});\n这是用Promise对象处理过的回调嵌套,但每次都需要重复书写then,使得原来的语义看起来不是很清楚,这时候认为代码亢余。\n但正如此处的代码一般,若希望使用Promise对象处理回调,代码亢余是不可避免的。\n',1016,0,'2020-07-11',0),(3173,'coroutine','协程',48,0,'2020-07-11',0),(3174,'协程','协程是一种概念,指多个线程互相协作,完成任务。\n如:\n执行任务A->执行50%->执行任务B->执行100%->继续任务A->执行100%\n可以看出,在运行流程中,A执行到指定处后,将控制权交给了B,等待其执行完成,自己才继续执行,此时可以认为A是异步的。\n\nES6有Generator函数,实现了半协程\nfunction *asyncJob() {\n  // ...其他代码\n  var f = yield readFile(fileA);\n  // ...其他代码\n}\nlet demo=asyncJob()\ndemo.next()\nconsole.log(111)\ndemo.next()\n在这段代码中,执行者本来是asyncJob函数,执行到yield语句时,就将执行权交还了主线程。\n主线程输出111后,又将执行权交给函数继续执行,这就是一种半协程。\n至于只是半协程的原因,是因为只有Generator函数的调用者,才能够将执行权交还给Generator函数。\n',1016,0,'2020-07-11',0),(3175,'generator.throw','一、概述\n该方法用于在Generator函数外部抛出一个错误,并使其在Generator函数体内捕获。\n\n二、语法\ngenerator.throw(err)\nerr: Error错误实例,将传入作为Generator函数体catch块的第一个参数\n\n三、示例\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error(\'出错了！\'));\n// Error: 出错了！(...)\n',44,0,'2020-07-11',0),(3176,'求值策略','求值策略,即函数的参数应该什么时候求值。\nfunction demo(a){\n  console.log(a+5)\n}\n\n有一种意见是\'传值调用\'(call by value),即进入函数体之前,就计算参数的结果,并将这个结果传入函数。\ndemo(1+2)\n\'传值调用\'将会先计算参数的结果,如此处是1+2,就会计算出3,将3赋给函数的参数a后,返回结果。\nC语言就采用了这种求值策略。\n\n第二种意见是\'传名调用\'(call by name),即将整个参数表达式传入函数体,在用到的时候才计算它的结果。\ndemo(1+2)\n\'传名调用\'会将整个参数表达式传入,如此处是1+2,就会将1+2赋给函数体内的形参a,然后a+5就会变成1+2+5。\n\n\'传值调用\'的好处显而易见,它不必在每次用到指定参数都计算它的结果。但是它的缺点也显而易见,如果函数体内没有用到这个参数,也会计算这个参数的结果,这显得没有必要。\n',1016,0,'2020-07-12',0),(3177,'recursion','递归',48,0,'2020-07-12',0),(3178,'async函数','一、概述\nasync函数是Generator的语法糖。\n\n二、示例\nfunction createTimeout(ms){\n  return new Promise((resolve)=>{\n    setTimeout(resolve,ms)\n  })\n}\nfunction* gen(){\n  yield createTimeout(1000)\n  console.log(1)\n  yield createTimeout(2000)\n  console.log(2)\n  yield createTimeout(3000)\n  return 3\n}\nlet g = gen()\ng.next().value.then(()=>{\n  g.next().value.then(()=>{\n    g.next().value.then(()=>{\n      console.log(g.next().value)\n    })\n  })\n})\n\n以上代码是正常的Generator函数写法,它会在1000毫秒后输出1,再经过2000毫秒输出2,再经过3000毫秒返回并输出3。\n\n以下代码通过async语法糖包装后的写法:\nfunction createTimeout(ms){\n  return new Promise((resolve)=>{\n    setTimeout(resolve,ms)\n  })\n}\nasync function gen(){\n  await createTimeout(1000)\n  console.log(1)\n  await createTimeout(2000)\n  console.log(2)\n  await createTimeout(3000)\n  return 3\n}\nlet g = gen().then((val)=>console.log(val))\n\n这段代码和上面的结果是一样的,但语法上简洁了很多。\n在gen函数被调用后,生成器就开始自动执行,在Promise函数处暂停时会等待其状态变更再继续执行接下来的函数。\n\n三、详细分析\n1.语法\nasync本质上是Generator的包装语法糖,它的声明和Generator不同,通过async function声明async函数,并且使用await替代原来的yield。\n\n2.执行过程\n执行async函数将在其每个暂停处返回的Promise对象状态更改后自动继续执行next。\n这个async函数它将返回一个Promise对象,该对象resolved返回函数的第一个参数为该async函数最后return返回的结果。\n\n3.错误捕获\n当函数内部Promise的异步执行过程中抛出错误,或更改了状态为reject,整个async函数都会中断执行。并且这个错误被这个返回的Promise对象接收到,并同步更改它的状态为reject。\n如果不希望函数内部Promise的异步执行过程中状态变更为reject或抛出错误后,使整个async函数中断,可以用try..catch..包裹代码块,或者在这个Promise对象后写个catch方法。\n\n3.非继发关系\n若两个回调函数之间没有依赖关系,写成以下这种方式就比较浪费时间:\nlet foo = await getFoo()\nlet bar = await getBar()\n因为这将等待第一个回调函数返回结果,才会去执行第二个回调函数,但他们又没有依赖关系,显得比较浪费时间。\nlet [foo,bar] = await Promise.all([getFoo(),getBar()])\n通过Promise.all就能完美的解决这个问题。\n\n\n\n',1084,0,'2020-07-13',0),(3179,'浏览器并发机制','浏览器默认对同一域下的资源，只保持一定的连接数,阻塞过多的连接,以提高访问速度和解决阻塞问题。\n不同浏览器的默认允许并发连接数不同,且不同的http协议也不一样,如:IE6,7在使用http/1.1的情况下允许同时有2个并行连接,在使用http/1.0的情况下允许同时有4个并行连接。而IE8无论是使用http/1.0还是http/1.1,都是统一允许同时由6个并行连接。\n而设置连接超时自动断开(如axios的timeout)时,超过指定的时间,这次请求就会中断,并移除请求队列。\n\n解决浏览器并发阻塞的方法有:\n1.服务对应域名,增加出口\n浏览器是限制一个域名同时发送N个请求，但如果是2个域名都同时请求。\n那么最大发送请求数 = 域名数目 * 浏览器最大并行请求数；\n如chrome最大发送请求数：12=2*6。\n就是2个服务的站点分出去，谁阻塞就找谁服务。\n\n2.设置timeout请求超时时间\n加上timeout就会按timeout时间清除队列。保持队列定时清空，就可以发出请求。\n\n',1016,0,'2020-07-15',0),(3180,'code','代码;编码',48,0,'2020-07-13',0),(3181,'propagation','传播',48,0,'2020-07-13',0),(3182,'document.readyState','该属性描述了document的加载状态。\n该属性发生变化时,会触发document.readystatechange事件。\n\n可能值:\n1.loading(正在加载)\n  document 仍在加载。\n2.interactive(可交互)\n  文档已被解析，\"正在加载\"状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。\n3.complete(完成)\n  文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。',57,0,'2020-07-13',0),(3183,'readystatechange','浏览器document对象的readyState属性发生改变时触发该事件。\n',1082,0,'2020-07-13',0),(3184,'DOMContentLoaded','当初始的html文档被加载和解析完成后,DOMContentLoaded事件被触发,而无需等待样式表,图像和子框架的完全加载。\n\nie低版本不支持该事件,可以使用事件readystatechange进行兼容。',1082,0,'2020-07-14',0),(3185,'engine','引擎',48,0,'2020-07-14',0),(3186,'backend','后端',48,0,'2020-07-14',0),(3187,'reflow','回流',48,0,'2020-07-14',0),(3188,'trigger','触发',48,0,'2020-07-14',0),(3189,'defer','推迟',48,0,'2020-07-14',0),(3190,'defer','限定元素:<script>\n\n添加该属性的script脚本将与dom解析并行加载,并且在其自身解析完成之后,且dom也解析完成之后,执行其中的脚本,然后才是触发domContentLoaded事件。\n注意,添加了defer属性的script脚本不会改变它与其他脚本的执行顺序。',31,0,'2020-07-14',0),(3191,'async','限定元素:<script>\n\n添加了该属性的script脚本将异步执行,即可以与dom解析等并行执行,但与defer不同,添加了async属性的脚本只要加载完了就会自动执行其中的脚本,而不会等待dom的解析或是其他内容的加载。\n因为async-script是会加载完成后自动执行,所以不能保证它们的执行顺序与出现顺序一致。\n此外,添加了async属性的script脚本不会阻塞DomContentLoaded事件的触发,但会阻塞window.onload事件的触发。\n动态添加的script标签默认该属性为true。',31,0,'2020-07-14',0),(3192,'parser','解析器',48,0,'2020-07-14',0),(3193,'attachment','附件',48,0,'2020-07-14',0),(3194,'reflow回流','回流(reflow)指浏览器发现某个元素属性的改变影响了布局,影响到的这一部分元素就要重新渲染.有时甚至需要整个文档重新进行渲染,这个就叫做回流。\n如修改元素的width属性,使其周围元素的布局都发生了改变,这一部分元素就会重新渲染,引发回流。',35,0,'2020-07-14',0),(3195,'repaint重绘','重绘(repaint)指修改了元素的某个内部属性,如color,background等不影响元素布局的属性时,需要对该元素和其子元素进行重新绘制,这个就叫重绘。\n不同于回流,重绘对性能的影响要小很多。',35,0,'2020-07-14',0),(3196,'renderer','渲染器',48,0,'2020-07-14',0),(3197,'process','进程',48,0,'2020-07-14',0),(3198,'thread','线程',48,0,'2020-07-14',0),(3200,'communication','通讯',48,0,'2020-07-17',0),(3202,'inter-(前缀)','在..之间',48,0,'2020-07-14',0),(3203,'IPC','全名Inter-Process Communication,即进程间通信。\n指至少两个进程或线程间传输数据或信号的一些技术或方法。',1014,0,'2020-07-15',0),(3204,'plugin','插入',48,0,'2020-07-14',0),(3205,'graphics','图形',48,0,'2020-07-15',0),(3206,'GPU','全名Graphics Processing Unit,即图像处理器。',1014,0,'2020-07-14',0),(3208,'site','网站;位置',48,0,'2020-07-14',0),(3209,'Isolation','隔离',48,0,'2020-07-14',0),(3210,'heap','堆',48,0,'2020-07-14',0),(3211,'virtual','虚拟',48,0,'2020-07-14',0),(3212,'copy','用户复制元素内文本时触发事件。',1082,0,'2020-07-14',0),(3213,'patch','补丁',48,0,'2020-07-14',0),(3214,'diff','差异',48,0,'2020-07-15',0),(3215,'LiveReLoad','配合本地网页实时更新,能在网页上立即看到效果。',1093,0,'2020-07-15',0),(3216,'Tampermonkey','油猴,可以自己写或者安装一些别人写的脚本,这些脚本会在进入某个特定网页时自动运行。\n\n比如给bilibili添加一些按钮什么的',1093,0,'2020-07-15',0),(3217,'Chrome UA Spoofer','可以用Chrome浏览器模拟其他的浏览器内核,比如模拟IE6,火狐的内核等。',1093,0,'2020-07-15',0),(3218,'Astar VPN','开着就能上谷歌商店,或者谷歌搜索引擎之类被墙的东西了。',1093,0,'2020-07-15',0),(3219,'FeHelper','这个插件内置了很多功能,比较有意思的比如:\n1.网页栅格标尺\n可以查看鼠标悬停处的像素坐标。\n2.网页截屏工具\n可以直接截屏,也可以滚动截屏(让滚动条滚动一个页面的距离,如果还没到底端,就继续往下滚动,然后将截取到的图片全都结合成一张)。',1093,0,'2020-07-15',0),(3220,'exist','存在',48,0,'2020-07-15',0),(3221,'document.setAttribute()','设置元素节点的属性。\n\n语法:document.setAttribute(key,val)\nkey:属性名\nval:属性值',58,17,'2020-07-16',0),(3222,'javascript console utils','ctrl+shift+L 快速在选中变量下生成console.log显示它的语句\nctrl+shift+D 快速删除所有console.log语句',1037,0,'2020-07-16',0),(3223,'document.removeAttribute()','删除对象的指定属性。\n\n语法:document.removeAttribute(key)\nkey:属性键名',58,14,'2020-07-16',0),(3224,'document.getAttribute()','获取对象指定属性的键值。\n\n语法:document.getAttribute(key)\nkey:指定属性键名',58,19,'2020-07-16',0),(3225,'hoist','提升',48,0,'2020-07-17',0),(3226,'class类','一、概述\nes6提供了class的形式定义构造函数的方法,它是一个构造函数的语法糖。\n\n二、基本示例\nclass Demo{\n  constructor(x,y){\n    this.x = x\n    this.y = y\n  }\n  \n  sayHi(){\n    console.log(\'Hello World\')\n  }\n}\n上面代码中,定义了一个Demo类,constructor为该类的入口函数。\n每当通过new调用Demo类,就新生成一个Demo类的实例并将该实例对象作为this调用constructor内部的代码。\nlet d = new Demo(1,2)\nconsole.log(d.y) //=>2\n\n除了constructor,在类内部定义的其他方法均可以视为在原型链上定义的方法。也就是说,本例中的sayHi和以下方式差不多是等价的:\nDemo.prototype.sayHi = function(){\n  console.log(\'Hello World\')\n}\n但它们也不完全相同,在Class内部定义的原型方法默认是不可遍历的,而使用原型链写的方法则需要自己添加特性。\n\n三、静态方法(static)\nclass Demo{\n  constructor(){\n    /* ... */\n  }\n  static sayYo(){\n    console.log(\'Yo\')\n  }\n}\n本例中,使用了static关键字定义了方法sayYo(),该方法将被定义在类本身,即:\nDemo.sayYo() //=>Yo\n通过static关键字定义的静态方法不会被实例继承。\n(new Demo()).sayYo() //=> Error\n\n四、类继承(extends)\nclass Demo2 extends Demo{\n  constructor(x,y,z){\n    super(x,y)\n    this.z = z\n  }\n}\nclass允许使用extends关键字指明继承的类,然后在构造函数内部通过super,将自身实例作为父类实例传入并返回。\n需要注意的是,子类必须在构造函数顶端使用super继承父类属性,若在super声明前调用了this,将声明this不存在。\n此外,extends将继承父类所有的静态方法。\nDemo2.sayYo() //=>Yo\n\n五、其他\n1.class不存在变量提升\n2.class定义的函数数据类型为\'function\'(其实就是es5的对象构造函数换了个写法)\n3.class定义的函数无法只能通过new调用,不能直接被调用(有别于es5的写法)\n4.静态属性目前只能通过在类外部给类添加属性来定义\n5.类的属性名,可以使用方括号表达式\n6.类内部,默认使用严格模式\n',1084,0,'2020-07-17',0),(3227,'decorator','修饰器',48,0,'2020-07-17',0),(3228,'@import','可以在css代码中使用@import导入其他css文件的样式。\n示例:\n@import url(http://...)\np{\n  /* ...*/\n}\n/* ... */',33,0,'2020-07-17',0),(3232,'JS模块化规范','在es6以前,为了引入js模块化,CommonJS、AMD、CMD三个规范应运而生。\nes6从语言层面提供了模块化支持,可以取代掉这些规范。\n\n1.CommonJS\nCommonJS规范主要是为了实现js在服务端上的模块化,它分为{模块引用(require)} {模块定义(exports)} {模块标识(module)}。\nrequire用来引入其他模块\nexports用来导出当前模块\nmodule则是当前模块的对象\nNode.js就遵循了这个规范,也做了稍稍的改动。\n\n2.AMD\nAMD规范是为了实现js在客户端上的模块化,服务器和客户端分别使用不同的规范主要是CommonJs是同步加载的,目前客户端上的js还没有同步加载的条件。\nAMD规范只有一个接口\ndefine(id?,dependencies?,factory)\n它在声明模块时指定所有的依赖,然后将这些依赖作为参数传入factory中。\nrequire.js遵循了该规范\n\n3.CMD\nCMD比较特殊,它是seajs的开发者遵循该框架提出的规范,和AMD比较相似。\ndefine(function(require,exports,module){...})\nCMD和AMD的区别可以在官方文档查看。\n\n4.es6\n',1016,0,'2020-07-17',0),(3233,'constant','常量',48,0,'2020-07-17',0),(3234,'ES6原生模块语法','一、概述\nes6之前,为了使用模块化编程,社区指定了CommonJs和AMD,CMD规范,遵循这些规范开发的框架(如require.js)和运行环境(如node)可以使用模块化变成。\n而es6支持了原生的模块语法,可以完全替代在浏览器和服务器上的js模块化编程规范。\n\n二、基本示例\n// module.js\nlet a = 1\nexport { a }\n以上代码用于向外导出一个接口,该接口有一个属性值a\n\n// demo.js\nimport {a} from \'./module.js\'\nconsole.log(a) //=>1\n以上代码用于导入模块,并获取其接口的a属性\na = 2 //=>Error\n试图改变这个导出接口的属性时会报错,因为这个接口与模块内部的值是动态绑定的。\n\n也就是说,在导出模块后如果导出接口的值发生了改变,接收的值也会发生改变。\n// module.js\nlet a = 1\nexport { a }\nsetTimeout(()=>{\n  a = 333\n},50)\n\n// demo.js\nimport {a} from \'./module.js\'\nconsole.log(a) //=>1\nsetTimeout(()=>{\n  console.log(a) //=>333\n},100)\n注意这点与CommonJS,AMD等规范是不同的,这些规范获取的值是缓存的拷贝。\n\n可以使用as关键字重命名接口属性:\n1.对于export语句,as会改变所有其他模块import导入该模块属性时的属性名\nexport {a as www}\n将a属性重命名为www并导出\n2.对于import语句,as会改变当前文件内对指定模块接口属性的属性敏感\nimport {a as www} from \'./module.js\'\n\n此外,模块文件内默认都是严格模式的。\n\n三、import语句的运行\nimport语句是在编译阶段运行的,也就是说,它不能使用运行时才能获得结果的语法结果。\n错误示例:\n1.使用js表达式\nimport {\'f\'+\'oo\'} from \'./module.js\'\n此处用了运算符,它只在运行时能得出结果\n\n2.使用变量保存值\nlet module = \'./module.js\'\nimport {foo} from module\n\n3.使用判断结构\nif(flag){\n  import {foo} from \'./module1.js\'\n} else {\n  import {foo} from \'./module2.js\'\n}\n当然,循环什么的也不行。\n\n四、模块的载入\n模块会在被导入时自动执行,但只会执行一次,之后再次被导入将返回上一次载入的结果。\n如果只希望执行模块语句,可以这么写:\nimport \"./module.js\"\n\n五、模块的整体加载\n导入模块时可以使用*将模块的所有属性置于一个对象中并返回这个对象。\n// module.js\nlet a = 1, b = 2\nexport {a,b}\n\n// demo.js\nimport * as obj from \'./module.js\'\nconsole.log(obj.a) //=>1\nconsole.log(obj.b) //=>2\n\n六、模块的默认导出\n可以使用export default指定模块的默认输出,import时可以用任意变量名导入该接口。\n// module.js\nexport default function gulu(){/* ... */}\n\n// demo.js\nimport ohye from \'./module.js\'\n注意,通过这种方式导出的对象不需要加大括号,而且原来的对象名将无效。\n\n模块可以同时定义默认导出和其他接口\n// module.js\nexport default function gulu(){/* ... */}\nlet a = 1, b = 2\nexport {a,b}\n\n// demo.js\nimport ohye,{a,b} from \'./module.js\'\n默认导出和其他接口通过逗号分隔。\n\n七、复合写法\n如果希望导入后立即导出一个模块,可以这么写:\nexport {a,b} from \'./module.js\'\n\n八、浏览器模块脚本文件的导入\n通过为<script>标签定义属性type为module指定该脚本为es6模板文件,否则无法正常使用。\n此外,浏览器会默认其defer属性为true\n',1084,0,'2020-07-18',0),(3235,'Node引入模块路径查找顺序','对于CommonJS规范和es6原生模块,查找顺序相同:\n例a: import \'./foo\'\n查找顺序:\n1.\'./foo.js\'\n2.\'./foo/package.json\'\n3.\'./foo/index.js\'\n\n例b: import \'foo\'\n查找顺序:\n1.\'./node_modules/foo.js\'\n2.\'./node_modules/foo/package.json\'\n3.\'./node_modules/foo/index.js\'\n4.当前目录的上级目录重复1-3\n5.当前目录的上级目录的上级目录重复1-3\n6.。。。\n',1016,0,'2020-07-18',0),(3236,'Node的CommonJS与es6模块兼容','在静态分析阶段,模块脚本只要有一行import或export语句,视为es6模块。\nNode环境下,使用import加载CommonJS模块,会将其module.exports输出视为export default。',1016,0,'2020-07-18',0),(3237,'模块循环加载','在模块A中引用模块B,模块B又引用模块A,这个就是循环加载,它在实际开发环境中往往难以避免。\n\n1.CommonJS\n对于CommonJS规范,由于模块是运行时加载,模块A中运行到引用模块B的语句时会先暂停执行模块A,进入模块B中执行。\n此时模块B执行到引用模块A的语句,则会进入模块A,执行模块A已加载的部分,也就是说,引用模块B之前的所有语句。\n自然,循环加载冲突也就不存在。\n\n2.ES6模块\n对于ES6原生模块,由于模块是编译时加载,每个模块只会执行一次,因此但模块B再去调用模块A,它会直接返回上次的结果,自然循环冲突也不存在。\n\n',1016,0,'2020-07-18',0),(3238,'let和const的取舍','在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n\nconst优于let有几个原因:\n1.const可以提醒阅读程序的人，这个变量不应该改变。\n\n2.const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算。\n\n3.JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\n\n',1016,1,'2020-07-18',0),(3239,'task','任务',48,0,'2020-07-18',0),(3240,'macro','宏',48,0,'2020-07-18',0),(3241,'micro','微',48,0,'2020-07-18',0),(3242,'queue','队列',48,0,'2020-07-18',0),(3243,'宏任务/微任务','参考资料:https://zhuanlan.zhihu.com/p/80074274\n\n由于js是一门单线程语言,所有任务都需要进行排队,如果一个任务执行时间过长,下一个任务的执行就会很晚,因此,js将任务分为了同步执行和异步执行。\n异步执行的任务将会在同步任务都执行完时开始执行,如setTimeout等在特殊条件环境下执行的异步等,则会由执行环境代管,在满足该条件时间任务添加入任务队列。\n\n而宏任务与微任务,则是任务的细分,当主线程上的宏任务都执行完成时,才会执行微任务。\n宏任务包括:\n1.script整体代码;\n2.setTimeout\n3.setInterval\n4.Promise.prototype.resolve\n...\n微任务包括:\n1.Promise.prototype.then\n2.process.nextTick(Node环境)\n...\n\n如:\nconsole.log(1)\nsetTimeout(()=>{\n  console.log(2)\n},0)\nPromise.resolve().then(()=>{\n  console.log(3)\n}).then(()=>{\n  console.log(4)\n})\nconsole.log(5)\n以上代码中,程序自上而下执行。\n1.遇到console.log(1),将其输出;\n2.遇到setTimeout,将其加入宏任务队列;\n3.遇到Promise.resolve(),由于初始状态为非pending,将立即执行;\n4.遇到Promise.resolve().then(),将其加入微任务队列;\n5.遇到console.log(5),将其输出;\n6.主线程已清空,将微任务添加进主线程继续执行;\n7.执行Promise.resolve().then(),遇到console.log(3),将其输出;\n8.遇到Promise.resolve().then().then(),将其添加入微任务队列;\n9.主线程已清空,将微任务添加进主线程继续执行;\n10.执行Promise.resolve().then().then(),遇到console.log(4),将其输出;\n11.主线程已清空,微任务已清空,开始新一轮事件循环(event loop)\n12.将宏任务添加进主线程\n13.执行setTimeout,遇到console.log(2),将其输出。\n14.所有事件执行完毕。\n因此输出顺序为:15342\n\n\n\n',1016,0,'2020-07-18',0),(3244,'DOCTYPE 的作用','声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。\n\nBackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。\n\nCSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。\n\n这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat\n\n这也就是恶魔的开始 -- 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。\n\n如果你的页面添加了<!DOCTYPE html>那么，那么就等同于开启了标准模式\n\n那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。\n\n此外,该声明能够告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。\n对于html5,直接写<!DOCTYPE html>就好\n对于其他html或xhtml规范,可以在网上查阅对应的声明方式。\n\n',33,0,'2020-07-18',0),(3245,'<blockquote>','表示元素内文本是引用的',1095,0,'2020-07-18',0),(3246,'<address>','表示元素内文本是文档/文章的拥有者的联系信息。',1095,0,'2020-07-18',0),(3247,'void空元素指的是什么','指无须闭合标签的元素。\n类似于<br/><input/><hr/><img/><link/><meta/>等。',35,0,'2020-07-18',0),(3248,'<p>','该元素定义段落。',1095,8,'2020-07-18',0),(3249,'<h1>-<h6>','定义标题元素,从h1到h6字号逐渐缩小。',1095,10,'2020-07-18',0),(3250,'<div>','定义无特殊含义的块级元素',1095,11,'2020-07-18',0),(3251,'<ul>','定义无序列表。',1095,7,'2020-07-18',0),(3252,'<ol>','定义有序列表',1095,6,'2020-07-18',0),(3253,'<li>','定义无序列表或有序列表的每一列。',1095,5,'2020-07-18',0),(3254,'<span>','定义文本元素。',1096,0,'2020-07-18',0),(3255,'<mark>','突出显示部分文本。',1096,0,'2020-07-18',0),(3256,'<em>','定义斜体文本。',1096,0,'2020-07-18',0),(3257,'<strong>','定义粗体文本。',1096,0,'2020-07-18',0),(3258,'<a>','超链接标签。',1096,0,'2020-07-18',0),(3259,'<sup>','定义上标文本。',1096,0,'2020-07-18',0),(3260,'<sub>','定义下标文本。',1096,0,'2020-07-18',0),(3261,'Trident','IE浏览器所用的内核。',1097,0,'2020-07-18',0),(3262,'Gecko','Firefox浏览器内核。',1097,0,'2020-07-18',0),(3263,'Webkit','Safari浏览器的内核。\n\n常见浏览器:\n1.Safari浏览器\n2.Android默认浏览器\n3.Apple Safari(Win/Mac/iPhone/iPad)',1097,0,'2020-07-18',0),(3264,'Blink','Chrome浏览器的内核。\n\n常见浏览器:\n1.Chorme\n2.Opera',1097,0,'2020-07-18',0),(3265,'key属性的作用','key用来指定元素的唯一标识,单个页面下每个元素都不能有重复的key。\n在vue中,页面渲染时,是根据元素的位置生成虚拟dom的,如:\n<ul>\n  <li id=\"a\">111</li>\n</ul>\n此时就会判断a元素的位置是ul的第一个li元素。\n若希望在a元素前添加一个元素b,像这样:\n<ul>\n  <li id=\"b\">222</li>\n  <li id=\"a\">111</li>\n</ul>\n此时将认为原位置的a元素被更新,id替换为b,文本节点替换为222,然后新建了一个文本节点为111的a元素,重新渲染。\n当然结果是没错的,但这个过程消耗了较多的内存,后面只有一个元素还好说,上百个呢?这上百个全都会被认为是替换或更新,重新进行渲染。\n若有一个元素标识key,在页面渲染时会自动找到对应key的元素进行比对,则:\n<ul>\n  <li id=\"b\">222</li>\n  <li id=\"a\" :key=\"a\">111</li>\n</ul>\n此时页面渲染时,自动找到对应key的元素进行比对,发现该元素没有改变,自然就不会进行其后的渲染,而新插入的元素则会被视为添加到ul的头部。\n\n',1009,0,'2020-07-18',0),(3266,'open in browser','安装此插件后可以右键html选择\"View in Browser\"以用默认浏览器打开该html文件。',1037,3,'2020-07-19',0),(3267,'babel转码器','1.简介\n将es6或更改版本的js脚本编译为es5的脚本\n\n2.安装\ncnpm i babel-core -S\ncnpm i babel-preset-env -S\ncnpm i babel-cli -g(全局)\n\n3.使用\n在项目根目录下新建文件.babelrc并设置内容如下:\n{\n  \"presets\": [\n    \"env\"\n  ],\n  \"plugins\": []\n}\n\n然后通过babel-node app.js运行项目\n',45,0,'2020-07-20',0),(3268,'declare','声明',48,0,'2020-07-20',0),(3269,'variable','变量',48,0,'2020-07-21',0),(3270,'内存泄漏','内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。',1016,0,'2020-07-22',0),(3271,'什么时候句末一定要加分号','当一行语句以(,[,{,\\,+,-,`作为开头时,必须给上一行末尾打分号,否则js解析器会解析错误。',1016,0,'2020-07-23',0),(3272,'access','访问',48,0,'2020-07-23',0),(3273,'贪婪匹配/非贪婪匹配','比如说字符串 aabab\n什么都不加，默认贪婪模式\na.*b 能匹配abab\n非贪婪模式，加?号\na.*?b能匹配aab和ab',50,0,'2020-07-23',0),(3274,'AOT/JIT','AOT即提前编译(Ahead of time),也称为静态编译。\n指程序在执行前先将所有代码转换成机器码。\n\nJIT即即时编译(Just in time),也称为动态解释。\n指程序一句一句编译后执行。',1014,0,'2020-07-24',0),(3275,'编译器和解释器是什么','AOT即提前编译(Ahead of time),也称为静态编译。\n指程序在执行前先将所有代码转换成机器码。\n\nJIT即即时编译(Just in time),也称为动态解释。\n指程序一句一句编译后执行。\n\n编译器: 将源代码转换成低级语言的程序,即AOT运行时的工具。\n解释器: 直接执行用编程语言编写的指令的程序,即JIT运行时的工具。',1016,0,'2020-07-24',0),(3276,'parse','解析;编译',48,0,'2020-07-24',0),(3277,'语法单元','语法单元是被解析语法当中具备实际意义的最小单元。\n\nJavascript 代码中的语法单元主要包括以下这么几种:\n1.关键字：例如 var、let、const等\n2.标识符：没有被引号括起来的连续字符，可能是一个变量，也可能是 if、else 这些关键字，又或者是 true、false 这些内置常量\n3.运算符： +、-、 *、/ 等\n4.数字：像十六进制，十进制，八进制以及科学表达式等语法\n5.字符串：因为对计算机而言，字符串的内容会参与计算或显示\n6.空格：连续的空格，换行，缩进等\n7.注释：行注释或块注释都是一个不可拆分的最小语法单元\n8.其他：大括号、小括号、分号、冒号等\n',1016,0,'2020-07-24',0),(3278,'identifier','标识符',48,0,'2020-07-24',0),(3279,'punctuator','标点符号',48,0,'2020-07-24',0),(3280,'Numeric','数字',48,0,'2020-07-24',0),(3281,'标题','# 一级标题\n## 二级标题\n...\n###### 六级标题',1100,0,'2020-07-24',0),(3282,'段落换行','1.使用两个以上的空格+回车表示换行。\n2.使用两个连续换行符表示换行。',1100,0,'2020-07-24',0),(3283,'斜体文本','*斜体文本*',1100,0,'2020-07-24',0),(3284,'粗体文本','**粗体文本**',1100,0,'2020-07-24',0),(3286,'分隔线','***(行内不能有其他东西)',1100,0,'2020-07-24',0),(3287,'删除线','~~文本~~',1100,0,'2020-07-24',0),(3288,'下划线','使用html的<u>文本</u>',1100,0,'2020-07-24',0),(3289,'脚注','[^要注明的文本]',1100,0,'2020-07-24',0),(3290,'无序列表','无序列表使用+,-或*代表每一列,后面要加上空格。\n+ 第一项\n+ 第二项\n+ 第三项',1100,0,'2020-07-24',0),(3291,'有序列表','有序列表用数字.加上一个空格表示\n1. 第一项\n2. 第二项\n3. 第三项',1100,0,'2020-07-24',0),(3292,'列表嵌套','列表嵌套在嵌套列前加四个空格即可,如:\n1. 第一大项\n    1. 第一小项\n    2. 第二小项\n2. 第二大项',1100,0,'2020-07-24',0),(3293,'区块','用> 表示区块引用\n> 引用文本\n',1100,0,'2020-07-24',0),(3294,'区块嵌套','可以用多个>表示内层嵌套。\n> 外层嵌套\n>> 第二层嵌套\n>>> 第三层嵌套',1100,0,'2020-07-24',0),(3295,'列表中使用区块','在区块前加上4个空格以在列表中使用区块\n1. 列表1\n    > 区块1\n    > 区块2\n2. 列表2',1100,0,'2020-07-24',0),(3296,'代码片段(短)','可以用`将文本包裹以表示代码片段。\n`代码文本`\n这种写法一般用于短代码。',1100,0,'2020-07-24',0),(3297,'代码区块','使用```包裹的文本表示代码区块。\n```\nconsole.log(1)\n```\n也可以指定使用的语言\n```javascript\nconsole.log(2)\n```',1100,0,'2020-07-24',0),(3298,'链接','可以使用[链接名](链接地址)表示一个链接。\n[百度](https://www.baidu.com/)\n\n也可以用<>包裹,不指定链接名直接写链接地址。\n<https://www.baidu.com/>',1100,0,'2020-07-24',0),(3299,'图片','通过一个感叹号!+[alt属性值]+(图片地址)定义图片\n![RUNOOB图标](http://static.runoob.com/images/runoob-logo.png)\n\n可以通过在图片地址后+空格+双引号包裹文本以定义title属性值\n![RUNOOB图标](http://static.runoob.com/images/runoob-logo.png \"RUNOOB\")\n',1100,0,'2020-07-24',0),(3300,'表格','使用|分隔不同的单元格,在表头后使用一行----分隔的单元格表示一行共有多少列。\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n可以在----定义的列前后使用冒号声明该列的对齐方式。\n|  表头   | 表头  | 表头 |\n|  :----  | ----:  |  :----: |\n| 单元格  | 单元格 | 单元格 |\n| 单元格  | 单元格 | 单元格 |\n以上,\n第一列将左对齐,\n第二列将右对齐,\n第三列将居中对齐。\n',1100,0,'2020-07-24',0),(3301,'<u>','内部文本加上下划线',1096,0,'2020-07-24',0);
/*!40000 ALTER TABLE `dt_h3` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-07-24 16:44:34
